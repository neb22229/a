<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>ZTap-Arena — Deep-Space Nebula+ (Full Update Pass v2)</title>
<style>
  html,body{margin:0;height:100%;background:#06080f;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;color:#e6f0ff}
  canvas{display:block;width:100vw;height:100vh;touch-action:none;cursor:crosshair}
</style>
</head>
<body>
<canvas id="game"></canvas>
<script>
/*
FULL UPDATE PASS v2 (adds missing bits)
- Spark of Life: on revive -> spread=2, haste=2, BoostAll 4s (plus existing spawn protection).
- Multi-kill scoring: when the combo window closes (combo>=2), award bonus points and show flair burst.
- Cosmetics Store:
  • Bullet skins: 'classic', 'ion', 'plasma'
  • Scoreboard fx: 'default', 'ember', 'ice'
  • Background theme: 'nebula', 'violet', 'amber'
  • Enemy skin: 'default', 'pastel'
  • Multi-kill flair (on/off)
- All cosmetics persist in localStorage and affect rendering.
- SW cache bump -> v5.
*/

// ===== Canvas setup =====
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d', { alpha:false });
const isMobile = /Mobi|Android|iPhone/i.test(navigator.userAgent);
let W=1,H=1,DPR=1,UIS=1;
function resize(){
  const vw = Math.max(1, document.documentElement.clientWidth || innerWidth || 320);
  const vh = Math.max(1, document.documentElement.clientHeight || innerHeight || 240);
  DPR = isMobile ? Math.min(2, (window.devicePixelRatio||1)) : (window.devicePixelRatio||1);
  W = (vw*DPR)|0; H = (vh*DPR)|0; canvas.width=W; canvas.height=H; canvas.style.width=vw+'px'; canvas.style.height=vh+'px';
  UIS = Math.min(1, Math.max(0.8, Math.min(vw,vh)/720));
  initBackdrop();
}
addEventListener('resize', resize, {passive:true});

function showError(msg){ try{ ctx.setTransform(1,0,0,1,0,0); ctx.fillStyle='#220'; ctx.fillRect(0,0,W,H); ctx.fillStyle='#fbb'; ctx.fillText('⚠ '+String(msg).slice(0,200), 10*DPR, 20*DPR);}catch(_){} }
addEventListener('error',e=>showError(e.message||e.error));
addEventListener('unhandledrejection',e=>showError(e.reason));

// ===== Persistent meta =====
const meta = {
  currency: 0,
  bestScore: 0,
  firstTimeRewards: { '5000': false, '10000': false, '25000': false },
  purchases: {
    skin:'teal', sparkOfLife:0,
    bulletSkin:'classic',   // classic | ion | plasma
    scoreFx:'default',      // default | ember | ice
    bgTheme:'nebula',       // nebula | violet | amber
    enemySkin:'default',    // default | pastel
    multiKillFlair:true
  },
};
function loadMeta(){
  try{
    const m=JSON.parse(localStorage.getItem('ztap_meta')||'null');
    if(m){ Object.assign(meta,m); if(!meta.purchases) meta.purchases={}; }
  }catch(e){}
}
function saveMeta(){ try{ localStorage.setItem('ztap_meta', JSON.stringify(meta)); }catch(e){} }
loadMeta();

// ===== Game state =====
const state={
  time:0, shake:0, hitstop:0,
  score:0, displayScore:0, scorePulse:0,
  lives:3, wave:1, gameOver:false,
  enemies:[], bullets:[], enemyShots:[],
  // Background layers
  stars:[], nebula:[], galaxies:[], comets:[],
  trails:[], ripples:[], floaters:[], particles:[], powerups:[], cometsFX:[],
  lastSpawn:0, spawnDelay:650, waveTarget:12, spawned:0,
  lastShot:0, shootDelay:380,
  activePointers:new Set(), lastTapTime:0, lastTapX:0, lastTapY:0,
  bombs:1, invuln:0,
  spreadLevel:0, hasteLevel:0,
  mult:1, multTimer:0, multCap:3, geomCapReached:false, tempMultBoost:0,
  banner:{text:'',t:0},
  joy:{ active:false, ox:0, oy:0, x:0, y:0, a:0, t:0 },
  cometTimer: 0, bgPulse: 0,
  enemySlowT:0, magnetT:0, boostAllT:0,
  combo:0, comboT:0, comboWindow:1100, grazes:0,
  lastComboAwarded:0,
  lostLifeThisWave:false,
  showStart:true, hasMoved:false,
  showOptions:false, showStore:false, showBoard:false,
  aimMode:'auto', inputMode:'both', muted:false,
  bonusMode:false, bonusT:0, revivePending:false, pbNotified:false,
};
const player={ x:0,y:0, tx:0,ty:0, r:16, speed:0.38, color:'#00ffcc', skin:'teal', lastMoveDX:1, lastMoveDY:0, shielded:false };

// ===== Utils =====
const rand=(a,b)=>a+Math.random()*(b-a);
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
function drawStar(x,y,points,outerR,innerR,rot){ ctx.beginPath(); rot=rot||-Math.PI/2; const step=Math.PI/points; for(let i=0;i<points*2;i++){ const r=(i%2===0? outerR:innerR); const a=rot+i*step; const sx=x+Math.cos(a)*r, sy=y+Math.sin(a)*r; i?ctx.lineTo(sx,sy):ctx.moveTo(sx,sy);} ctx.closePath(); }
function hueForType(t){
  const base = (meta.purchases.enemySkin==='pastel') ? {weaver:320, orbiter:180, charger:10, shooter:150, grunt:270} : {weaver:310, orbiter:160, charger:0, shooter:140, grunt:260};
  return base[t] ?? 260;
}
function colorForType(t,a=1){ const h=hueForType(t); return `hsla(${h},85%,65%,${a})`; }
function outlineForType(t,a=0.12){ return `hsla(${hueForType(t)},100%,100%,${a})`; }

// ===== Backdrop =====
function initBackdrop(){
  const starCount=Math.max(90,Math.floor((W*H)/11000)); const stars=[];
  for(let i=0;i<starCount;i++) stars.push({x:Math.random()*W,y:Math.random()*H,z:Math.random()<0.6?0.5:1,tw:Math.random()*6});
  state.stars=stars;

  const theme = meta.purchases.bgTheme||'nebula';
  const palette = theme==='violet' ? ['rgba(170,120,255,0.16)','rgba(120,90,255,0.12)','rgba(255,160,220,0.14)']
                   : theme==='amber' ? ['rgba(255,170,120,0.16)','rgba(255,210,120,0.10)','rgba(255,120,120,0.12)']
                   : ['rgba(100,160,255,0.10)','rgba(190,110,255,0.16)','rgba(90,230,220,0.16)'];

  const N = [];
  const blobs = 3 + ((theme!=='nebula')?1:0);
  for(let i=0;i<blobs;i++){
    const c = palette[i%palette.length];
    N.push({x:W*rand(0.2,0.8), y:H*rand(0.2,0.8), r:rand(100,180)*DPR, baseR:rand(100,180)*DPR, color:c, phase:rand(0,6.28), speed:rand(0.0007,0.0012)});
  }
  state.nebula = N;

  const G=[];
  const makeGalaxy=(z)=>({
    x: rand(W*0.15, W*0.85), y: rand(H*0.15, H*0.85),
    z, rot: rand(0,Math.PI*2), rotSpeed: rand(0.0002,0.0005),
    rx: rand(160,260)*DPR, ry: rand(80,160)*DPR,
    hue: rand(180,330)
  });
  G.push(makeGalaxy(0.35)); G.push(makeGalaxy(0.6));
  state.galaxies = G;
  state.cometTimer = rand(12000, 22000);
}
function waveGradient(){
  const theme = meta.purchases.bgTheme||'nebula';
  if(theme==='violet') return ['#160a26','#0a0614'];
  if(theme==='amber')  return ['#1f1208','#090604'];
  return ['#0b1020','#05070a'];
}
function drawBackground(){
  const pulse = Math.max(0, state.bgPulse||0); const boost = 1 + 0.5*pulse;
  const [c0,c1] = waveGradient();
  const g=ctx.createRadialGradient(W/2,H/2,0,W/2,H/2,Math.max(W,H)/1.05);
  g.addColorStop(0, c0); g.addColorStop(0.55, '#0f1730'); g.addColorStop(1, c1);
  ctx.fillStyle=g; ctx.fillRect(0,0,W,H);

  // galaxies
  ctx.save();
  for(const gal of state.galaxies){
    const parx=(player.x-W/2)*0.00025*(gal.z*60), pary=(player.y-H/2)*0.00025*(gal.z*60);
    const x=((gal.x + parx) % W + W)%W, y=((gal.y + pary) % H + H)%H;
    ctx.save(); ctx.translate(x,y); ctx.rotate(gal.rot);
    ctx.scale(gal.rx, gal.ry);
    const rg=ctx.createRadialGradient(0,0,0,0,0,1);
    const h=gal.hue;
    rg.addColorStop(0, `hsla(${h},80%,70%,${0.12*boost})`);
    rg.addColorStop(0.4, `hsla(${(h+40)%360},90%,60%,${0.09*boost})`);
    rg.addColorStop(1, 'hsla(0,0%,0%,0)');
    ctx.fillStyle=rg; ctx.beginPath(); ctx.arc(0,0,1,0,Math.PI*2); ctx.fill();
    ctx.restore();
  }
  ctx.restore();

  // nebula
  ctx.save(); ctx.globalCompositeOperation='lighter';
  for(let i=0;i<state.nebula.length;i++){
    const n=state.nebula[i];
    const r = n.baseR * (1.1 + 0.2*Math.sin((state.time*n.speed)+n.phase));
    const grd=ctx.createRadialGradient(n.x,n.y,0,n.x,n.y,r);
    grd.addColorStop(0, n.color); grd.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle=grd; ctx.beginPath(); ctx.arc(n.x,n.y,r*1.15,0,Math.PI*2); ctx.fill();
  }
  ctx.restore();

  // stars
  ctx.save(); ctx.globalAlpha=0.98;
  for(const s of state.stars){
    const r=(s.z===1?1.9:1.1)*DPR;
    ctx.beginPath(); ctx.arc(s.x,s.y,r,0,Math.PI*2);
    ctx.fillStyle=s.z===1?'#20508a':'#153252'; ctx.fill();
    if((s.tw%6)<0.26){
      ctx.beginPath(); ctx.arc(s.x,s.y,r*1.7,0,Math.PI*2);
      ctx.globalAlpha=0.18; ctx.fillStyle='#8bd0ff'; ctx.fill(); ctx.globalAlpha=0.98;
    }
  }
  ctx.restore();

  // subtle grid
  const cell=Math.max(28,40*DPR*UIS); ctx.globalAlpha=0.10; ctx.beginPath(); const t2=state.time*0.00025;
  for(let x=((t2*60)%cell)-cell; x<W; x+=cell){ ctx.moveTo(x,0); ctx.lineTo(x,H);}
  for(let y=((t2*40)%cell)-cell; y<H; y+=cell){ ctx.moveTo(0,y); ctx.lineTo(W,y);}
  ctx.strokeStyle='#0e1a2c'; ctx.lineWidth=1; ctx.stroke(); ctx.globalAlpha=1;

  // comets
  ctx.save();
  for(const c of state.comets){
    ctx.globalCompositeOperation='lighter';
    const trail = Math.max(10*DPR, c.len*0.6);
    const ang = Math.atan2(c.vy, c.vx);
    ctx.save(); ctx.translate(c.x, c.y); ctx.rotate(ang);
    const cg = ctx.createLinearGradient(-trail,0,0,0);
    cg.addColorStop(0, 'rgba(124,195,255,0)');
    cg.addColorStop(1, 'rgba(124,195,255,0.9)');
    ctx.fillStyle=cg; ctx.beginPath(); ctx.ellipse(-trail/2, 0, trail/2, 2*DPR, 0, 0, Math.PI*2); ctx.fill();
    ctx.globalAlpha=1; ctx.beginPath(); ctx.arc(0,0, 2.2*DPR, 0, Math.PI*2); ctx.fillStyle='#e6f9ff'; ctx.fill();
    ctx.restore();
  }
  ctx.restore();
}

// ===== Enemies =====
function pickEnemyType(){
  const w=state.wave, pool=[]; const push=(t,n)=>{for(let i=0;i<n;i++) pool.push(t)};
  push('grunt',8);
  if(w>=2) push('weaver', Math.min(5, 1+Math.floor(w/2)));
  if(w>=3) push('charger',Math.min(3,Math.floor((w-2)/2)));
  if(w>=4) push('orbiter',Math.min(3,Math.floor((w-3)/2)));
  if(w>=5) push('shooter',Math.min(2,Math.floor((w-4)/2)));
  return pool[Math.floor(Math.random()*pool.length)]||'grunt';
}
const ENEMY_DEF = {
  grunt:   { baseHP:1,  points:10 },
  weaver:  { baseHP:1,  points:12 },
  orbiter: { baseHP:2,  points:16 },
  charger: { baseHP:2,  points:20 },
  shooter: { baseHP:2,  points:18 },
};
function spawnEnemy(forceType){
  const m=24*DPR; const edge=(Math.random()*4)|0; let x,y;
  if(edge===0){x=rand(m,W-m);y=-m;} else if(edge===1){x=W+m;y=rand(m,H-m);} else if(edge===2){x=rand(m,W-m);y=H+m;} else {x=-m;y=rand(m,H-m);}
  let type=forceType||pickEnemyType();
  if(!forceType && state.wave>=2 && (state.spawned % 3 === 0)) type='weaver';
  // scale hp with waves (basic enemies gain hp later)
  let hp = ENEMY_DEF[type].baseHP + (state.wave>=8 && type==='grunt' ? 1 : 0) + (state.wave>=14 && type==='grunt' ? 1 : 0);
  const common={x,y, px:x,py:y, t:0, alive:true, type, hp, maxhp:hp};
  if(type==='grunt')   state.enemies.push({...common,r:12*DPR,speed:rand(0.08,0.12)*DPR});
  else if(type==='weaver')  state.enemies.push({...common,r:11*DPR,speed:rand(0.08,0.11)*DPR,sway:rand(0.003,0.006),phase:rand(0,Math.PI*2),tail:[]});
  else if(type==='orbiter') state.enemies.push({...common,r:12*DPR,angle:rand(0,Math.PI*2),radius:rand(70,110)*DPR});
  else if(type==='charger') state.enemies.push({...common,r:12*DPR,speed:0.09*DPR,phase:'aim',wind:320,vx:0,vy:0,dashSpeed:0.5*DPR});
  else if(type==='shooter') state.enemies.push({...common,r:12*DPR,speed:0.06*DPR,desired:rand(160,220)*DPR,fireCD:rand(700,1000)});
  state.spawned++;
}
function nextWave(){
  if(!state.lostLifeThisWave){
    const bonus = 100 + 10*state.wave;
    state.score += bonus;
    addFloater(player.x, player.y-20*DPR, 'Flawless +' + bonus);
    meta.currency += 2; saveMeta();
  }
  state.lostLifeThisWave = false;

  state.wave++; state.waveTarget+=5; state.spawned=0;
  state.lastSpawn=0; state.spawnDelay=Math.max(260,state.spawnDelay*0.9);
  state.shootDelay=Math.max(300,state.shootDelay*0.96);
  dropBanner(`Wave ${state.wave}`);
  if(state.wave%10===0){ triggerBonusLevel(); }
  if(state.wave>=2){ spawnEnemy('weaver'); }
  state.cometTimer = Math.min(state.cometTimer, 800);
}

// ===== FX & helpers =====
function addFloater(x,y,text,col){ state.floaters.push({x,y,text,a:1,vy:-0.05*DPR, col:col||'#fff'}); }
function addBurst(x,y,n=16, col){ for(let i=0;i<n;i++){ const a=Math.random()*Math.PI*2, s=rand(0.6,2.0)*DPR; state.particles.push({x,y,vx:Math.cos(a)*s,vy:Math.sin(a)*s,r:rand(1,3)*DPR,a:1,col:col||'#6bbcff'}); } }
function dropBanner(text){ state.banner.text=text; state.banner.t=1600; }
function killImpact(x,y){ state.hitstop=Math.max(state.hitstop,60); state.ripples.push({x,y,r:10*DPR,max:100*DPR,a:0.9}); }
function spawnPowerup(type,x,y){ state.powerups.push({type,x,y,t:0,r:11*DPR,a:1}); }
function awardCurrency(n, x, y){ meta.currency += n; saveMeta(); addFloater(x||player.x, y||player.y, '₵+'+n, '#ffd866'); }

// ===== Combat/Aim =====
function segHitsCircle(x1,y1,x2,y2,cx,cy,r){
  const dx=x2-x1, dy=y2-y1; const a=dx*dx+dy*dy;
  if(a===0){ return Math.hypot(cx-x1, cy-y1) <= r; }
  let t=((cx-x1)*dx + (cy-y1)*dy)/a; if(t<0) t=0; else if(t>1) t=1;
  const px=x1 + dx*t, py=y1 + dy*t; return Math.hypot(px-cx,py-cy) <= r;
}
function getNearestEnemy(){ let best=Infinity, pick=null; for(const e of state.enemies){ if(!e.alive) continue; const d=Math.hypot(e.x-player.x,e.y-player.y); if(d<best){best=d; pick=e;} } return pick; }
function shoot(now){
  const hasteFactor = Math.max(0.6, 1 - 0.18*state.hasteLevel) * (state.boostAllT>0 ? 0.85 : 1);
  if(now-state.lastShot < state.shootDelay*hasteFactor) return;

  let baseAngle = 0, haveDir = false;
  if(state.aimMode==='directional'){
    const dx=player.lastMoveDX, dy=player.lastMoveDY, len=Math.hypot(dx,dy);
    if(len>0.01){ baseAngle = Math.atan2(dy,dx); haveDir=true; }
  }
  if(!haveDir){
    const e=getNearestEnemy(); if(!e) return;
    const dx=e.x-player.x, dy=e.y-player.y;
    baseAngle=Math.atan2(dy,dx);
  }
  const speed=8*DPR*(state.boostAllT>0?1.15:1);
  const level=state.spreadLevel + (state.boostAllT>0?1:0);
  const angles= level<=0?[0]:(level===1?[-0.12,0,0.12]:[-0.21,-0.09,0,0.09,0.21]);
  for(const off of angles){
    const a=baseAngle+off;
    const bullet={x:player.x,y:player.y, px:player.x,py:player.y, vx:Math.cos(a)*speed, vy:Math.sin(a)*speed, r:3*DPR, life:900};
    state.bullets.push(bullet);
  }
  state.lastShot=now;
}
function detonateBomb(){
  if(state.bombs<=0||state.gameOver) return;
  state.bombs--;
  let killed = 0;
  for(const e of state.enemies){
    if(e.alive){
      e.alive = false;
      const col=colorForType(e.type);
      addBurst(e.x,e.y, (e.type==='charger'||e.type==='shooter'||e.type==='orbiter') ? 28 : 18, col);
      state.score += ENEMY_DEF[e.type].points*state.mult;
      killed++;
    }
  }
  state.enemyShots.length = 0;
  state.shake += Math.min(24*DPR, 8*DPR + killed*0.7*DPR);
  killImpact(player.x,player.y);
  addFloater(player.x,player.y,'BOMB!');
  state.bgPulse = 1.0;
}

// ===== Input & Overlays =====
function screenToCanvas(e){
  const rect=canvas.getBoundingClientRect();
  const px=clamp((e.clientX-rect.left)*DPR,0,W);
  const py=clamp((e.clientY-rect.top)*DPR,0,H);
  return {px,py};
}
function within(x,y,rx,ry,rw,rh){ return x>=rx && x<=rx+rw && y>=ry && y<=ry+rh; }

canvas.addEventListener('pointerdown',e=>{
  const {px,py}=screenToCanvas(e);
  if(state.showOptions){ if(handleOptionsClick(px,py)) return; }
  if(state.showStore){ if(handleStoreClick(px,py)) return; }
  if(state.showBoard){ state.showBoard=false; return; }

  if(state.gameOver){
    if(handleEndScreenClick(px,py)) return;
    boot(); return;
  }

  if(state.showStart && !state.hasMoved){ if(handleStartButtons(px,py)) return; }

  state.activePointers.add(e.pointerId);
  player.tx=px; player.ty=py;

  if(state.inputMode!=='tap'){
    if(state.activePointers.size===1){ state.joy.active=true; state.joy.ox=px; state.joy.oy=py; state.joy.x=px; state.joy.y=py; state.joy.a=1; state.joy.t=0; }
  }

  if(state.activePointers.size>=2 && state.bombs>0){ detonateBomb(); return; }
  const now=performance.now(); const dt=now-state.lastTapTime; const near=Math.hypot(px-state.lastTapX,py-state.lastTapY)<20*DPR; if(dt<300 && near && state.bombs>0){ detonateBomb(); }
  state.lastTapTime=now; state.lastTapX=px; state.lastTapY=py;
},{passive:true});
canvas.addEventListener('pointermove',e=>{
  if(!state.activePointers.has(e.pointerId)) return;
  const {px,py}=screenToCanvas(e);
  player.tx=px; player.ty=py; state.joy.x=px; state.joy.y=py; state.joy.a=Math.min(1, state.joy.a + 0.02);
  if(!state.hasMoved){ if(Math.hypot(player.tx - (W/2), player.ty - (H/2)) > 6*DPR){ state.hasMoved=true; state.showStart=false; } }
},{passive:true});
canvas.addEventListener('pointerup',e=>{ state.activePointers.delete(e.pointerId); if(state.activePointers.size===0){ state.joy.active=false; }},{passive:true});
canvas.addEventListener('pointercancel',e=>{ state.activePointers.delete(e.pointerId); if(state.activePointers.size===0){ state.joy.active=false; }},{passive:true});

// ===== Update =====
function update(dt,now){
  const ts=(state.hitstop>0||state.gameOver)?0.25:1; state.hitstop=Math.max(0,state.hitstop-dt);
  state.time += dt*ts;

  state.displayScore += (state.score-state.displayScore)*0.18;
  state.invuln=Math.max(0,state.invuln-dt);
  state.enemySlowT=Math.max(0,state.enemySlowT-dt);
  state.magnetT=Math.max(0,state.magnetT-dt);
  state.boostAllT=Math.max(0,state.boostAllT-dt);
  state.tempMultBoost=Math.max(0,state.tempMultBoost-dt);
  state.comboT=Math.max(0,state.comboT-dt);

  // Multi-kill resolve bonus
  if(state.comboT<=0 && state.combo>1){
    // award once per closure
    if(state.lastComboAwarded !== state.time|0){
      const bonus = 5*state.combo; // simple linear bonus
      state.score += bonus;
      addFloater(W/2, H*0.22, 'MULTI x'+state.combo+'  +'+bonus, '#ffd866');
      if(meta.purchases.multiKillFlair){ addBurst(W/2, H*0.22, 24, '#ffd866'); state.shake += 4*DPR; }
      state.lastComboAwarded = state.time|0;
    }
  }
  if(state.comboT<=0) state.combo=0;

  if(!state.pbNotified && state.score>meta.bestScore && state.score>0){
    addFloater(W/2, H*0.3, 'NEW PERSONAL BEST!', '#b0ff9b'); state.pbNotified=true;
  }

  // Threshold rewards
  const thresholds=[5000,10000,25000];
  for(const th of thresholds){
    if(state.score>=th && !meta.firstTimeRewards[String(th)]){
      meta.firstTimeRewards[String(th)]=true; const c = th>=25000?20: th>=10000?10:5;
      awardCurrency(c, W/2, H*0.36); addFloater(W/2, H*0.36+14*DPR, 'Reward Unlocked: '+th, '#ffd866'); saveMeta();
    }
  }

  // galaxies/stars motion
  for(const gal of state.galaxies){ gal.rot += gal.rotSpeed*dt; }
  const ox=(player.x-W/2)*0.00025, oy=(player.y-H/2)*0.00025;
  for(const s of state.stars){ s.x+=ox*(s.z===1?14:7); s.y+=oy*(s.z===1?14:7); if(s.x<0)s.x+=W; if(s.x>W)s.x-=W; if(s.y<0)s.y+=H; if(s.y>H)s.y-=H; s.tw+=dt*0.01; }
  for(let i=0;i<state.nebula.length;i++){ const n=state.nebula[i]; n.x += Math.sin((state.time*0.0001)+i)*0.1*DPR; n.y += Math.cos((state.time*0.00008)+i)*0.08*DPR; }

  // comets
  state.cometTimer -= dt; if(state.cometTimer<=0){
    const edge = (Math.random()*4)|0; let x,y,vx,vy; const speed = rand(0.25,0.45)*DPR; const angJitter = rand(-0.25,0.25);
    if(edge===0){ x=-20*DPR; y=rand(0,H); const ang = 0+angJitter; vx=Math.cos(ang)*speed; vy=Math.sin(ang)*speed; }
    else if(edge===1){ x=W+20*DPR; y=rand(0,H); const ang = Math.PI+angJitter; vx=Math.cos(ang)*speed; vy=Math.sin(ang)*speed; }
    else if(edge===2){ x=rand(0,W); y=-20*DPR; const ang = Math.PI/2+angJitter; vx=Math.cos(ang)*speed; vy=Math.sin(ang)*speed; }
    else { x=rand(0,W); y=H+20*DPR; const ang = -Math.PI/2+angJitter; vx=Math.cos(ang)*speed; vy=Math.sin(ang)*speed; }
    state.comets.push({x,y,vx,vy,life:rand(900,1400),len:rand(50,110)});
    const base = rand(12000, 22000); const bonus = Math.max(0, 5000 - state.wave*400); state.cometTimer = Math.max(6000, base - bonus);
  }
  for(const c of state.comets){ c.x+=c.vx*dt; c.y+=c.vy*dt; c.life-=dt; }
  state.comets = state.comets.filter(c=> c.life>0 && c.x>-50 && c.x<W+50 && c.y>-50 && c.y<H+50);

  // movement
  state.trails.push({x:player.x,y:player.y,r:player.r,a:0.5}); state.trails=state.trails.filter(t=>(t.a-=0.02)>0);
  const dxp=player.tx-player.x, dyp=player.ty-player.y, lp=Math.hypot(dxp,dyp);
  if(lp>0.1){
    const moveSpeed = player.speed * (state.boostAllT>0?1.12:1);
    const step=Math.min(lp,moveSpeed*dt*ts);
    const nx=dxp/lp, ny=dyp/lp;
    player.x+=nx*step; player.y+=ny*step;
    player.lastMoveDX=nx; player.lastMoveDY=ny;
  }

  // spawns
  if(!state.bonusMode){
    state.lastSpawn+=dt*ts; if(state.spawned<state.waveTarget && state.lastSpawn>state.spawnDelay){ spawnEnemy(); state.lastSpawn=0; }
  }

  // enemies
  const slowM = state.enemySlowT>0 ? 0.65 : 1;
  for(const e of state.enemies){
    if(!e.alive) continue; e.px=e.x; e.py=e.y; e.t+=dt*ts;
    if(e.type==='grunt'){
      const dx=player.x-e.x, dy=player.y-e.y, l=Math.hypot(dx,dy)||1; e.x+=(dx/l)*e.speed*dt*ts*slowM; e.y+=(dy/l)*e.speed*dt*ts*slowM;
    } else if(e.type==='weaver'){
      const dx=player.x-e.x, dy=player.y-e.y, l=Math.hypot(dx,dy)||1; const nx=dx/l, ny=dy/l; const sx=-ny, sy=nx; const wiggle=Math.sin(e.t*e.sway+e.phase)*0.8;
      e.x+=(nx*e.speed+sx*e.speed*wiggle)*dt*ts*slowM; e.y+=(ny*e.speed+sy*e.speed*wiggle)*dt*ts*slowM;
      e.tail=e.tail||[]; const last=e.tail[e.tail.length-1]; if(!last || Math.hypot(e.x-last.x,e.y-last.y)>2.5*DPR){ e.tail.push({x:e.x,y:e.y}); if(e.tail.length>40) e.tail.shift(); }
    } else if(e.type==='orbiter'){
      e.angle=(e.angle||0)+0.0028*dt*ts*slowM; e.x=player.x+Math.cos(e.angle)*e.radius; e.y=player.y+Math.sin(e.angle)*e.radius;
    } else if(e.type==='charger'){
      if(e.phase==='aim'){
        const dx=player.x-e.x,dy=player.y-e.y,l=Math.hypot(dx,dy)||1; e.x+=(dx/l)*e.speed*dt*ts*slowM; e.y+=(dy/l)*e.speed*dt*ts*slowM; e.wind-=dt*ts;
        if(e.wind<=0){ const dx2=player.x-e.x,dy2=player.y-e.y,L=Math.hypot(dx2,dy2)||1; e.vx=(dx2/L)*e.dashSpeed; e.vy=(dy2/L)*e.dashSpeed; e.phase='dash'; e.dashT=260; }
      } else { e.x+=e.vx*dt*ts; e.y+=e.vy*dt*ts; e.dashT-=dt*ts; if(e.dashT<=0){ e.phase='aim'; e.wind=380; } }
    } else if(e.type==='shooter'){
      const dx=player.x-e.x,dy=player.y-e.y,l=Math.hypot(dx,dy)||1; const nx=dx/l,ny=dy/l; let mx=0,my=0; const ideal=e.desired; const d=l;
      if(d<ideal*0.9){ mx-=nx*e.speed*dt*ts*slowM; my-=ny*e.speed*dt*ts*slowM; }
      else if(d>ideal*1.1){ mx+=nx*e.speed*dt*ts*slowM; my+=ny*e.speed*dt*ts*slowM; }
      else { mx+=-ny*e.speed*0.6*dt*ts*slowM; my+=nx*e.speed*0.6*dt*ts*slowM; }
      e.x+=mx; e.y+=my; e.fireCD-=dt*ts; if(e.fireCD<=0){ const sx=(dx/l)*2.6*DPR, sy=(dy/l)*2.6*DPR; state.enemyShots.push({x:e.x,y:e.y,vx:sx,vy:sy,r:3*DPR,life:1800, grazed:false}); e.fireCD=rand(700,1100); }
    }
    if(Math.hypot(e.x-player.x,e.y-player.y) < (e.r+player.r)){
      if(state.invuln<=0 && !player.shielded){ onPlayerHit(); }
      else if(player.shielded){
        player.shielded=false; addFloater(player.x,player.y,'SHIELD BROKEN','#6bffea'); state.invuln=1200;
      }
    }
  }
  state.enemies = state.enemies.filter(e=>e.alive);

  // bullets
  for(const b of state.bullets){ b.px=b.x; b.py=b.y; b.x+=b.vx*ts; b.y+=b.vy*ts; b.life-=dt*ts; }
  for(const b of state.bullets){
    if(b.life<=0) continue;
    for(const e of state.enemies){
      if(!e.alive) continue;
      const R = e.r + b.r + 1.5*DPR;
      const hit = (segHitsCircle(b.px,b.py,b.x,b.y, e.x,e.y, R) ||
                   segHitsCircle(b.px,b.py,b.x,b.y, (e.px||e.x), (e.py||e.y), R) ||
                   segHitsCircle(b.px,b.py,b.x,b.y, ((e.x+(e.px||e.x))*0.5), ((e.y+(e.py||e.y))*0.5), R));
      if(hit){
        b.life=0;
        e.hp = (e.hp||1) - 1;
        const col = colorForType(e.type);
        addBurst(e.x,e.y,8,col);
        if(e.hp<=0){
          e.alive=false;
          const basePts = ENEMY_DEF[e.type].points;
          const killPts = basePts * (state.mult + (state.tempMultBoost>0?2:0));
          state.score += killPts;
          state.scorePulse=1;
          state.combo = Math.min(9, state.combo+1);
          state.comboT = state.comboWindow;
          addFloater(e.x,e.y,'+'+killPts, '#ffd866');
          state.shake += (e.type==='charger'||e.type==='shooter'||e.type==='orbiter') ? 6*DPR:3*DPR;
          // drops
          const roll=Math.random();
          if(roll < 0.06){ spawnPowerup('coin', e.x, e.y); }
          const allowGeom=!state.geomCapReached && state.mult<state.multCap;
          const geomCount=state.powerups.filter(p=>p.type==='geom').length;
          if(allowGeom && geomCount<3 && roll<0.18){ spawnPowerup('geom',e.x,e.y);}
          else {
            const big = (e.type==='charger'||e.type==='shooter'||e.type==='orbiter');
            if(big){ if(roll<0.24){ spawnRandomPU(e.x,e.y,true); } }
            else   { if(roll<0.07){ spawnRandomPU(e.x,e.y,false); } }
          }
          if(e.type!=='grunt') killImpact(e.x,e.y);
        }
        break;
      }
    }
  }
  state.bullets = state.bullets.filter(b=>b.life>0);

  // enemy shots
  for(const s of state.enemyShots){ s.x+=s.vx*ts; s.y+=s.vy*ts; s.life-=dt*ts;
    const d = Math.hypot(s.x-player.x,s.y-player.y);
    const hitR = s.r+player.r;
    if(d<hitR){
      if(state.invuln<=0 && !player.shielded){ s.life=0; onPlayerHit(); }
      else { if(player.shielded){ player.shielded=false; addFloater(player.x,player.y,'SHIELD BROKEN','#6bffea'); state.invuln=1200; } s.life=0; }
    }else{
      const grazeR = hitR + 8*DPR;
      if(!s.grazed && d<grazeR){ s.grazed=true; state.grazes++; state.score += 1; addFloater(player.x, player.y-18*DPR, 'Graze +1', '#b0ff9b'); }
    }
  }
  state.enemyShots = state.enemyShots.filter(s=>s.life>0);

  // pickups
  for(const p of state.powerups){
    p.t+=dt*ts;
    if(p.type!=='coin'){ p.y += Math.sin(p.t*0.003)*0.1*DPR; }
    if(state.magnetT>0){
      const dx=player.x-p.x, dy=player.y-p.y; const l=Math.hypot(dx,dy);
      if(l<220*DPR){ p.x += (dx/l)*0.45*DPR*dt; p.y += (dy/l)*0.45*DPR*dt; }
    }
  }
  for(const p of state.powerups){
    if(Math.hypot(p.x-player.x,p.y-player.y)<player.r+p.r){ collectPickup(p); p.a=0; }
  }
  state.powerups=state.powerups.filter(p=>p.a!==0);

  // bonus mode
  if(state.bonusMode){
    state.bonusT -= dt;
    if(state.bonusT<=0){ state.bonusMode=false; }
    else{
      if(Math.random()<0.02){ spawnRandomPU(rand(40*DPR, W-40*DPR), -10*DPR, true, true); }
      if(Math.random()<0.03){ spawnPowerup('coin', rand(20*DPR, W-20*DPR), -10*DPR); }
      for(const p of state.powerups){ p.y += 0.12*DPR*dt; }
    }
  }

  if(!state.bonusMode && state.spawned>=state.waveTarget && state.enemies.length===0){ nextWave(); }
}
function onPlayerHit(){
  state.lostLifeThisWave = true;
  addBurst(player.x,player.y,20,'#fff');
  state.shake=8*DPR; state.mult=1; state.multTimer=0; state.geomCapReached=false; state.scorePulse=1;
  state.enemyShots.length=0; state.enemies.length=0;
  state.lives--;
  if(state.lives>0){
    player.x=W/2; player.y=H/2; player.tx=player.x; player.ty=player.y;
    state.invuln=2500; addFloater(player.x,player.y,'-1 LIFE','#ff6b6b');
  } else { endRun(); }
}
function endRun(){
  state.gameOver=true; dropBanner('GAME OVER');
  const payout = Math.max(1, Math.floor(state.score/2000)) + Math.floor(state.wave/5);
  awardCurrency(payout, W/2, H*0.45);
  if(state.score>meta.bestScore){ meta.bestScore=state.score; saveMeta(); }
}

// ===== Pickups =====
function spawnRandomPU(x,y,isBig,ignoreCap){
  const bag = ['hp','magnet','xmult','multibomb','boostall','slow','spread','haste','shield','bomb'];
  const pick = bag[(Math.random()*bag.length)|0];
  spawnPowerup(pick, x, y);
}
function collectPickup(p){
  let gainedScore = 5;
  if(p.type==='geom'){
    state.mult=Math.min(state.multCap,state.mult+1);
    if(state.mult>=state.multCap){ state.geomCapReached=true; }
    state.multTimer=6000;
    addFloater(p.x,p.y,'x'+state.mult);
    state.scorePulse=1;
  } else if(p.type==='coin'){
    awardCurrency(1, p.x, p.y);
    addFloater(p.x, p.y, '₵+1', '#ffd866');
    gainedScore = 0;
  } else if(p.type==='bomb'){
    const was = state.bombs; state.bombs=Math.min(9,state.bombs+1); addFloater(p.x,p.y,'BOMB+'); if(was===state.bombs) gainedScore += 10;
  } else if(p.type==='multibomb'){
    const before=state.bombs; state.bombs=Math.min(9,state.bombs+2); addFloater(p.x,p.y,'BOMBS+2'); if(before===state.bombs) gainedScore += 15;
  } else if(p.type==='shield'){
    player.shielded=true; addFloater(p.x,p.y,'SHIELD');
  } else if(p.type==='spread'){
    const before=state.spreadLevel; state.spreadLevel=Math.min(2,state.spreadLevel+1); addFloater(p.x,p.y,'SPREAD'); if(before===state.spreadLevel) gainedScore += 10;
  } else if(p.type==='haste'){
    const before=state.hasteLevel; state.hasteLevel=Math.min(2,state.hasteLevel+1); addFloater(p.x,p.y,'HASTE'); if(before===state.hasteLevel) gainedScore += 10;
  } else if(p.type==='hp'){
    const before=state.lives; state.lives=Math.min(6,state.lives+1); addFloater(p.x,p.y,'HP+'); if(before===state.lives) gainedScore += 10;
  } else if(p.type==='magnet'){
    state.magnetT = Math.max(state.magnetT, 6000); addFloater(p.x,p.y,'MAGNET');
  } else if(p.type==='xmult'){
    state.tempMultBoost = Math.max(state.tempMultBoost, 4000); addFloater(p.x,p.y,'MULT BOOST!','#ffd866');
  } else if(p.type==='boostall'){
    state.boostAllT = Math.max(state.boostAllT, 4000); addFloater(p.x,p.y,'BOOST ALL!','#ffd866');
  } else if(p.type==='slow'){
    state.enemySlowT = Math.max(state.enemySlowT, 5000); addFloater(p.x,p.y,'ENEMY SLOW','#ffd866');
  }
  if(gainedScore>0){ state.score += gainedScore; }
}

// ===== Draw =====
function drawJoystick(){ const j=state.joy; if(!j || j.a<=0 || state.inputMode==='tap') return; const baseR=26*UIS*DPR; const knobR=10*UIS*DPR; const dx=j.x-j.ox, dy=j.y-j.oy; const len=Math.hypot(dx,dy); const cap=48*UIS*DPR; const nx=len>0?dx/len:0, ny=len>0?dy/len:0; const kx=j.ox + nx*Math.min(len,cap); const ky=j.oy + ny*Math.min(len,cap);
  ctx.save(); ctx.globalAlpha=0.35*j.a; ctx.beginPath(); ctx.arc(j.ox,j.oy,baseR,0,Math.PI*2); ctx.fillStyle='#0e1a2c'; ctx.fill(); ctx.lineWidth=2*DPR; ctx.strokeStyle='rgba(124,195,255,0.6)'; ctx.stroke();
  ctx.beginPath(); ctx.moveTo(j.ox,j.oy); ctx.lineTo(kx,ky); ctx.strokeStyle='rgba(124,195,255,0.45)'; ctx.lineWidth=3*DPR; ctx.stroke();
  ctx.globalAlpha=0.8*j.a; ctx.beginPath(); ctx.arc(kx,ky,knobR,0,Math.PI*2); ctx.fillStyle='#7cc3ff'; ctx.shadowColor='#7cc3ff'; ctx.shadowBlur=8*DPR; ctx.fill(); ctx.restore(); }

function drawEnemyHP(e){
  if(e.maxhp<=1) return;
  const a = Math.max(0, Math.min(1, e.hp/e.maxhp));
  ctx.save();
  ctx.beginPath(); ctx.arc(e.x,e.y,e.r+4*DPR, -Math.PI/2, -Math.PI/2 + a*2*Math.PI);
  ctx.strokeStyle=colorForType(e.type, 0.9); ctx.lineWidth=2*DPR; ctx.stroke();
  ctx.restore();
}

function bulletColors(){
  const skin = meta.purchases.bulletSkin||'classic';
  if(skin==='ion')   return { trail:'#82bfff', tip:'#e6f9ff', stroke:'#9be0ff' };
  if(skin==='plasma')return { trail:'#ff9bf0', tip:'#ffe6fb', stroke:'#ffb6f5' };
  return { trail:'#9be0ff', tip:'#e6f9ff', stroke:'#9be0ff' };
}
function scoreFxColor(){
  const fx = meta.purchases.scoreFx||'default';
  if(fx==='ember') return '#ffd866';
  if(fx==='ice')   return '#b0fffb';
  return '#e6f0ff';
}

function draw(){
  ctx.clearRect(0,0,W,H);
  drawBackground();
  ctx.save();
  if(state.shake>0){ ctx.translate((Math.random()*2-1)*state.shake, (Math.random()*2-1)*state.shake); }

  // trails
  ctx.globalCompositeOperation='lighter';
  for(const t of state.trails){ ctx.globalAlpha=t.a; ctx.beginPath(); ctx.arc(t.x,t.y,t.r,0,Math.PI*2); ctx.fillStyle=player.color; ctx.fill(); }
  ctx.globalAlpha=1; ctx.globalCompositeOperation='source-over';

  // ripples
  for(const r of state.ripples){ ctx.beginPath(); ctx.arc(r.x,r.y,r.r,0,Math.PI*2); ctx.strokeStyle=`rgba(255,255,255,${Math.max(0,r.a)})`; ctx.lineWidth=2*DPR; ctx.stroke(); }

  // particles
  ctx.globalCompositeOperation='lighter';
  for(const p of state.particles){ ctx.globalAlpha=p.a; ctx.beginPath(); ctx.arc(p.x,p.y,p.r,0,Math.PI*2); ctx.fillStyle=p.col||'#6bbcff'; ctx.fill(); }
  ctx.globalAlpha=1; ctx.globalCompositeOperation='source-over';

  // enemies
  for(const e of state.enemies){
    ctx.save();
    const col=colorForType(e.type);
    ctx.shadowColor=col; ctx.shadowBlur=12*DPR; ctx.fillStyle=col;
    ctx.beginPath(); ctx.arc(e.x,e.y,e.r,0,Math.PI*2); ctx.fill();
    ctx.shadowBlur=0; ctx.strokeStyle=outlineForType(e.type,0.12); ctx.lineWidth=2*DPR; ctx.stroke();
    ctx.restore();
    drawEnemyHP(e);
  }

  // enemy shots
  ctx.globalCompositeOperation='lighter';
  for(const s of state.enemyShots){ ctx.beginPath(); ctx.arc(s.x,s.y,s.r,0,Math.PI*2); ctx.fillStyle='#ff9b9b'; ctx.fill(); }
  ctx.globalCompositeOperation='source-over';

  // pickups (iconography kept from v1 build)
  for(const p of state.powerups){
    const pulse=(Math.sin(p.t*0.01)+1)*0.5;
    ctx.save();
    if(p.type==='geom'){
      ctx.globalCompositeOperation='lighter'; ctx.translate(p.x,p.y); ctx.rotate(p.t*0.004); const r=p.r*(0.9+0.2*pulse);
      ctx.beginPath(); for(let i=0;i<6;i++){ const a=-Math.PI/2 + i*Math.PI/3; const xx=Math.cos(a)*r, yy=Math.sin(a)*r; i?ctx.lineTo(xx,yy):ctx.moveTo(xx,yy);} ctx.closePath(); ctx.strokeStyle='#ffd866'; ctx.lineWidth=3*DPR; ctx.stroke(); ctx.globalCompositeOperation='source-over';
    } else if(p.type==='bomb'){ ctx.translate(p.x,p.y); ctx.rotate(p.t*0.005); ctx.beginPath(); ctx.moveTo(0,-p.r); ctx.lineTo(p.r,0); ctx.lineTo(0,p.r); ctx.lineTo(-p.r,0); ctx.closePath(); ctx.fillStyle='#ffae6b'; ctx.fill();
    } else if(p.type==='shield'){ ctx.beginPath(); ctx.arc(p.x,p.y,p.r*(0.9+0.2*pulse),0,Math.PI*2); ctx.strokeStyle='#6bffea'; ctx.lineWidth=3*DPR; ctx.stroke();
    } else if(p.type==='spread'){ drawStar(p.x,p.y,5,p.r*1.1,p.r*0.5,p.t*0.004); ctx.fillStyle='#ffd2ff'; ctx.fill();
    } else if(p.type==='haste'){ ctx.save(); ctx.translate(p.x,p.y); ctx.rotate(p.t*0.006); ctx.beginPath(); ctx.moveTo(-0.2*p.r, -0.5*p.r); ctx.lineTo(0.18*p.r, -0.1*p.r); ctx.lineTo(-0.05*p.r, -0.1*p.r); ctx.lineTo(0.25*p.r, 0.5*p.r); ctx.lineTo(-0.25*p.r, 0.1*p.r); ctx.lineTo(0, 0.1*p.r); ctx.closePath(); ctx.fillStyle='#7cc3ff'; ctx.fill(); ctx.restore();
    } else if(p.type==='hp'){ ctx.beginPath(); ctx.arc(p.x,p.y,p.r*(0.9+0.2*pulse),0,Math.PI*2); ctx.fillStyle='#ff6b6b'; ctx.fill();
    } else if(p.type==='magnet'){ ctx.beginPath(); ctx.arc(p.x,p.y,p.r*(0.9+0.2*pulse),0,Math.PI*2); ctx.strokeStyle='#b0ff9b'; ctx.lineWidth=3*DPR; ctx.stroke();
    } else if(p.type==='xmult'){ ctx.beginPath(); ctx.arc(p.x,p.y,p.r*(0.9+0.2*pulse),0,Math.PI*2); ctx.strokeStyle='#ffd866'; ctx.lineWidth=3*DPR; ctx.stroke();
    } else if(p.type==='boostall'){ ctx.beginPath(); ctx.arc(p.x,p.y,p.r*(0.9+0.2*pulse),0,Math.PI*2); ctx.strokeStyle='#e6f9ff'; ctx.lineWidth=3*DPR; ctx.stroke();
    } else if(p.type==='slow'){ ctx.beginPath(); ctx.arc(p.x,p.y,p.r*(0.9+0.2*pulse),0,Math.PI*2); ctx.strokeStyle='#9be0ff'; ctx.lineWidth=3*DPR; ctx.stroke();
    } else if(p.type==='coin'){ ctx.beginPath(); ctx.arc(p.x,p.y,p.r*0.9,0,Math.PI*2); ctx.fillStyle='#ffd866'; ctx.fill(); }
    ctx.restore();
  }

  // bullets (skins)
  const bc = bulletColors();
  ctx.globalCompositeOperation='lighter';
  for(const b of state.bullets){
    ctx.beginPath(); ctx.moveTo(b.px,b.py); ctx.lineTo(b.x,b.y); ctx.strokeStyle=bc.stroke; ctx.lineWidth=2*DPR; ctx.stroke();
    ctx.beginPath(); ctx.arc(b.x,b.y,b.r,0,Math.PI*2); ctx.fillStyle=bc.tip; ctx.fill();
  }
  ctx.globalCompositeOperation='source-over';

  // player (skin)
  let skinColor = '#00ffcc';
  if(meta.purchases.skin==='lime') skinColor='#b0ff9b';
  else if(meta.purchases.skin==='magenta') skinColor='#ff7ad1';
  player.color = skinColor;
  ctx.save();
  ctx.shadowColor=player.color; ctx.shadowBlur=14*DPR; ctx.fillStyle=player.color;
  ctx.beginPath(); ctx.arc(player.x,player.y,player.r,0,Math.PI*2); ctx.fill();
  ctx.shadowBlur=0; ctx.strokeStyle='rgba(255,255,255,0.15)'; ctx.lineWidth=2*DPR; ctx.stroke();
  if(state.invuln>0 || player.shielded){
    ctx.beginPath(); ctx.arc(player.x,player.y,player.r+5*DPR,0,Math.PI*2);
    ctx.strokeStyle= player.shielded ? 'rgba(107,255,234,0.9)' : 'rgba(107,255,234,0.6)';
    ctx.lineWidth=2*DPR; ctx.stroke();
  }
  ctx.restore();

  // Scoreboard (FX)
  const scoreColor = state.tempMultBoost>0 ? '#ffd866' : (state.mult>=3 ? '#ffd866' : (state.mult===2 ? '#b0ff9b' : scoreFxColor()));
  const baseFont = 26*UIS*DPR;
  const multBoost = Math.max(0, state.mult-1) + (state.tempMultBoost>0?1:0);
  const pulseScale = 1 + 0.12*state.scorePulse;
  const multScale = 1 + 0.18*multBoost;
  const shakeAmp = (0.18 + 0.10*state.scorePulse) * multBoost * DPR;
  const t = state.time*0.02;
  const dx = Math.sin(t*7) * shakeAmp;
  const dy = Math.cos(t*9) * shakeAmp*0.4;
  ctx.save();
  const yTop = Math.max(16*UIS*DPR, 10*DPR) + dy;
  ctx.translate(W/2 + dx, yTop);
  ctx.scale(pulseScale*multScale, pulseScale*multScale);
  ctx.font = `${baseFont}px system-ui`;
  ctx.textAlign = 'center'; ctx.textBaseline = 'top';
  ctx.fillStyle = scoreColor; ctx.shadowColor = scoreColor;
  ctx.shadowBlur = (meta.purchases.scoreFx==='ember' ? 24 : meta.purchases.scoreFx==='ice' ? 18 : 12) * DPR + 10*multBoost*DPR;
  ctx.fillText(Math.round(state.displayScore).toLocaleString(), 0, 0);
  ctx.restore();

  // lives & HUD icons (same as v1)
  const lifeX=W-16*DPR, lifeY=18*UIS*DPR; ctx.save(); ctx.textAlign='right';
  for(let i=0;i<state.lives;i++){ ctx.beginPath(); ctx.arc(lifeX-i*18*DPR, lifeY, 6*DPR, 0, Math.PI*2); ctx.fillStyle='#ff6b6b'; ctx.fill(); }
  ctx.restore();

  const y = H-16*UIS*DPR; let x = 12*DPR; const r = 6*DPR;
  // simple glyphs for bombs/spread/haste
  ctx.save(); ctx.translate(x, y); ctx.rotate(0.2); ctx.beginPath(); ctx.moveTo(0,-r); ctx.lineTo(r,0); ctx.lineTo(0,r); ctx.lineTo(-r,0); ctx.closePath(); ctx.fillStyle='#ffae6b'; ctx.fill(); ctx.restore();
  ctx.fillStyle='rgba(230,240,255,0.9)'; ctx.font=`${12*UIS*DPR}px system-ui`; ctx.textAlign='left'; ctx.fillText('×'+state.bombs, x+10*DPR, y+4*DPR); x+=54*DPR;
  drawStar(x,y,5,r*1.1,r*0.5,0); ctx.fillStyle='#ffd2ff'; ctx.fill(); ctx.fillStyle='rgba(230,240,255,0.9)'; ctx.fillText('×'+state.spreadLevel, x+10*DPR, y+4*DPR); x+=54*DPR;
  ctx.save(); ctx.translate(x,y); ctx.rotate(0.4); ctx.beginPath(); ctx.moveTo(-0.2*r, -0.5*r); ctx.lineTo(0.18*r, -0.1*r); ctx.lineTo(-0.05*r, -0.1*r); ctx.lineTo(0.25*r, 0.5*r); ctx.lineTo(-0.25*r, 0.1*r); ctx.lineTo(0, 0.1*r); ctx.closePath(); ctx.fillStyle='#7cc3ff'; ctx.fill(); ctx.restore();
  ctx.fillStyle='rgba(230,240,255,0.9)'; ctx.fillText('×'+state.hasteLevel, x+10*DPR, y+4*DPR); x+=64*DPR;
  ctx.fillText(`Wave ${state.wave}   x${state.mult + (state.tempMultBoost>0?2:0)}`, x, y+4*DPR);
  if(player.shielded){ ctx.fillText(`  • Shield`, x+120*DPR, y+4*DPR); }
  if(state.magnetT>0){ ctx.fillText(`  • Magnet`, x+200*DPR, y+4*DPR); }
  if(state.boostAllT>0){ ctx.fillText(`  • BoostAll`, x+290*DPR, y+4*DPR); }
  if(state.enemySlowT>0){ ctx.fillText(`  • Slow`, x+400*DPR, y+4*DPR); }

  drawOverlays();
  ctx.restore();
}

// ===== Overlays & Store =====
function drawButton(label, x, y, w, h){
  ctx.save();
  ctx.fillStyle='rgba(10,18,30,0.75)'; ctx.fillRect(x,y,w,h);
  ctx.strokeStyle='rgba(124,195,255,0.7)'; ctx.lineWidth=2*DPR; ctx.strokeRect(x,y,w,h);
  ctx.fillStyle='rgba(230,240,255,0.95)'; ctx.font=`${14*UIS*DPR}px system-ui`; ctx.textAlign='center'; ctx.textBaseline='middle';
  ctx.fillText(label, x+w/2, y+h/2);
  ctx.restore();
}
function drawOverlays(){
  if(state.banner.t>0){ state.banner.t-=16; const a=Math.max(0,Math.min(1,state.banner.t/1600)); ctx.globalAlpha=a; ctx.font=`${28*UIS*DPR}px system-ui`; ctx.textAlign='center'; ctx.fillStyle='rgba(230,240,255,0.95)'; ctx.fillText(state.banner.text, W/2, H/2); ctx.globalAlpha=1; }

  if(state.showStart){
    ctx.save();
    ctx.fillStyle='rgba(0,0,0,0.35)'; ctx.fillRect(0,0,W,H);
    ctx.fillStyle='rgba(230,240,255,0.95)'; ctx.font=`${18*UIS*DPR}px system-ui`; ctx.textAlign='center';
    ctx.fillText('Drag to move • Double-tap or 2-finger for BOMB', W/2, H*0.4);
    const bw=120*DPR, bh=36*DPR, by=H-60*DPR;
    drawButton('Options',  W*0.2-bw/2, by, bw, bh);
    drawButton('Store',    W*0.5-bw/2, by, bw, bh);
    drawButton('Leaderboard', W*0.8-bw/2, by, bw, bh);
    ctx.restore();
  }

  if(state.showOptions){
    ctx.save();
    ctx.fillStyle='rgba(5,8,12,0.92)'; ctx.fillRect(W*0.2, H*0.2, W*0.6, H*0.6);
    ctx.fillStyle='#e6f0ff'; ctx.font=`${18*UIS*DPR}px system-ui`; ctx.textAlign='center'; ctx.fillText('Options', W*0.5, H*0.24);
    const bx=W*0.3, by=H*0.30, bw=W*0.4, bh=32*DPR, pad=42*DPR;
    drawButton('Input: '+state.inputMode.toUpperCase(), bx, by, bw, bh);
    drawButton('Aim: '+(state.aimMode==='auto'?'AUTO (closest)':'DIRECTIONAL'), bx, by+pad, bw, bh);
    drawButton('Mute: '+(state.muted?'ON':'OFF'), bx, by+pad*2, bw, bh);
    drawButton('Close', bx, by+pad*3, bw, bh);
    ctx.restore();
  }

  if(state.showStore){
    ctx.save();
    ctx.fillStyle='rgba(5,8,12,0.92)'; ctx.fillRect(W*0.12, H*0.12, W*0.76, H*0.76);
    ctx.fillStyle='#e6f0ff'; ctx.font=`${18*UIS*DPR}px system-ui`; ctx.textAlign='center'; ctx.fillText('Store', W*0.5, H*0.16);
    ctx.fillText('Currency: ₵'+meta.currency, W*0.5, H*0.20);

    const x=W*0.18, w=W*0.64, h=34*DPR; let y=H*0.24;
    // Consumables
    drawButton('Buy Spark of Life (₵50) — tokens: '+meta.purchases.sparkOfLife, x, y, w, h); y+=42*DPR;
    // Player skins
    drawButton('Skin: TEAL (₵0)  '+(meta.purchases.skin==='teal'?'[equipped]':''), x, y, w, h); y+=38*DPR;
    drawButton('Skin: LIME (₵10) '+(meta.purchases.skin==='lime'?'[equipped]':''), x, y, w, h); y+=38*DPR;
    drawButton('Skin: MAGENTA (₵10) '+(meta.purchases.skin==='magenta'?'[equipped]':''), x, y, w, h); y+=42*DPR;
    // Bullet skins
    drawButton('Bullet: CLASSIC (₵0) '+(meta.purchases.bulletSkin==='classic'?'[equipped]':''), x, y, w, h); y+=34*DPR;
    drawButton('Bullet: ION (₵8) '+(meta.purchases.bulletSkin==='ion'?'[equipped]':''), x, y, w, h); y+=34*DPR;
    drawButton('Bullet: PLASMA (₵8) '+(meta.purchases.bulletSkin==='plasma'?'[equipped]':''), x, y, w, h); y+=42*DPR;
    // Scoreboard FX
    drawButton('Score FX: DEFAULT (₵0) '+(meta.purchases.scoreFx==='default'?'[equipped]':''), x, y, w, h); y+=34*DPR;
    drawButton('Score FX: EMBER (₵6) '+(meta.purchases.scoreFx==='ember'?'[equipped]':''), x, y, w, h); y+=34*DPR;
    drawButton('Score FX: ICE (₵6) '+(meta.purchases.scoreFx==='ice'?'[equipped]':''), x, y, w, h); y+=42*DPR;
    // Background themes
    drawButton('Background: NEBULA (₵0) '+(meta.purchases.bgTheme==='nebula'?'[equipped]':''), x, y, w, h); y+=34*DPR;
    drawButton('Background: VIOLET (₵8) '+(meta.purchases.bgTheme==='violet'?'[equipped]':''), x, y, w, h); y+=34*DPR;
    drawButton('Background: AMBER (₵8) '+(meta.purchases.bgTheme==='amber'?'[equipped]':''), x, y, w, h); y+=42*DPR;
    // Enemy skins
    drawButton('Enemy Skin: DEFAULT (₵0) '+(meta.purchases.enemySkin==='default'?'[equipped]':''), x, y, w, h); y+=34*DPR;
    drawButton('Enemy Skin: PASTEL (₵8) '+(meta.purchases.enemySkin==='pastel'?'[equipped]':''), x, y, w, h); y+=42*DPR;
    // Multi-kill flair toggle
    drawButton('Multi-kill Flair: '+(meta.purchases.multiKillFlair?'ON':'OFF')+' (₵0)', x, y, w, h); y+=42*DPR;

    drawButton('Close', W*0.5-60*DPR, H*0.82, 120*DPR, 36*DPR);
    ctx.restore();
  }

  if(state.showBoard){
    ctx.save();
    ctx.fillStyle='rgba(5,8,12,0.92)'; ctx.fillRect(W*0.25, H*0.25, W*0.5, H*0.5);
    ctx.fillStyle='#e6f0ff'; ctx.font=`${18*UIS*DPR}px system-ui`; ctx.textAlign='center';
    ctx.fillText('Leaderboard — coming soon', W*0.5, H*0.43);
    ctx.fillText('(Future update)', W*0.5, H*0.46);
    drawButton('Close', W*0.5-60*DPR, H*0.62, 120*DPR, 36*DPR);
    ctx.restore();
  }

  if(state.gameOver){
    ctx.save();
    ctx.fillStyle='rgba(0,0,0,0.45)'; ctx.fillRect(0,0,W,H);
    ctx.fillStyle='rgba(230,240,255,0.95)'; ctx.font=`${18*UIS*DPR}px system-ui`; ctx.textAlign='center';
    ctx.fillText('Run Score: '+state.score.toLocaleString(), W/2, H*0.38);
    ctx.fillText('Best: '+meta.bestScore.toLocaleString(), W/2, H*0.41);
    if(state.score>=meta.bestScore){ ctx.fillText('New Personal Best!', W/2, H*0.44); }
    const bw=130*DPR, bh=36*DPR, gap=20*DPR, y=H*0.5;
    drawButton('Restart',    W*0.3-bw/2, y, bw, bh);
    drawButton('Revive (₵50)', W*0.5-bw/2, y, bw, bh);
    drawButton('Options',    W*0.7-bw/2, y, bw, bh);
    drawButton('Store',      W*0.4-bw/2, y+bh+gap, bw, bh);
    drawButton('Leaderboard',W*0.6-bw/2, y+bh+gap, bw, bh);
    ctx.restore();
  }
}
function handleStartButtons(px,py){
  const bw=120*DPR, bh=36*DPR, by=H-60*DPR;
  const opt={x: W*0.2-bw/2, y:by, w:bw, h:bh};
  const store={x: W*0.5-bw/2, y:by, w:bw, h:bh};
  const board={x: W*0.8-bw/2, y:by, w:bw, h:bh};
  if(within(px,py,opt.x,opt.y,opt.w,opt.h)){ state.showOptions=true; return true; }
  if(within(px,py,store.x,store.y,store.w,store.h)){ state.showStore=true; return true; }
  if(within(px,py,board.x,board.y,board.w,board.h)){ state.showBoard=true; return true; }
  return false;
}
function handleOptionsClick(px,py){
  const bx=W*0.3, by=H*0.30, bw=W*0.4, bh=32*DPR, pad=42*DPR;
  const r1={x:bx,y:by,w:bw,h:bh}, r2={x:bx,y:by+pad,w:bw,h:bh}, r3={x:bx,y:by+pad*2,w:bw,h:bh}, r4={x:bx,y:by+pad*3,w:bw,h:bh};
  if(within(px,py,r1.x,r1.y,r1.w,r1.h)){ state.inputMode = state.inputMode==='tap' ? 'drag' : (state.inputMode==='drag' ? 'both' : 'tap'); return true; }
  if(within(px,py,r2.x,r2.y,r2.w,r2.h)){ state.aimMode = state.aimMode==='auto' ? 'directional' : 'auto'; return true; }
  if(within(px,py,r3.x,r3.y,r3.w,r3.h)){ state.muted = !state.muted; return true; }
  if(within(px,py,r4.x,r4.y,r4.w,r4.h)){ state.showOptions=false; return true; }
  return false;
}
function handleStoreClick(px,py){
  const x=W*0.18, w=W*0.64, h=34*DPR; let y=H*0.24;
  const rows=[
    {k:'spark', rect:{x,y:y,w,h}}, {k:'skin_teal', rect:{x,y:y+=42*DPR,w,h}},
    {k:'skin_lime', rect:{x,y:y+=38*DPR,w,h}}, {k:'skin_magenta', rect:{x,y:y+=38*DPR,w,h}},
    {k:'b_classic', rect:{x,y:y+=42*DPR,w,h}}, {k:'b_ion', rect:{x,y:y+=34*DPR,w,h}}, {k:'b_plasma', rect:{x,y:y+=34*DPR,w,h}},
    {k:'fx_default', rect:{x,y:y+=42*DPR,w,h}}, {k:'fx_ember', rect:{x,y:y+=34*DPR,w,h}}, {k:'fx_ice', rect:{x,y:y+=34*DPR,w,h}},
    {k:'bg_neb', rect:{x,y:y+=42*DPR,w,h}}, {k:'bg_vio', rect:{x,y:y+=34*DPR,w,h}}, {k:'bg_amb', rect:{x,y:y+=34*DPR,w,h}},
    {k:'es_def', rect:{x,y:y+=42*DPR,w,h}}, {k:'es_pas', rect:{x,y:y+=34*DPR,w,h}},
    {k:'mk_toggle', rect:{x,y:y+=42*DPR,w,h}},
    {k:'close', rect:{x:W*0.5-60*DPR, y:H*0.82, w:120*DPR, h:36*DPR}}
  ];
  for(const r of rows){
    if(within(px,py,r.rect.x,r.rect.y,r.rect.w,r.rect.h)){
      switch(r.k){
        case 'spark':     if(meta.currency>=50){ meta.currency-=50; meta.purchases.sparkOfLife++; } break;
        case 'skin_teal': meta.purchases.skin='teal'; break;
        case 'skin_lime': if(meta.purchases.skin==='lime' || meta.currency>=10){ if(meta.purchases.skin!=='lime') meta.currency-=10; meta.purchases.skin='lime'; } break;
        case 'skin_magenta': if(meta.purchases.skin==='magenta' || meta.currency>=10){ if(meta.purchases.skin!=='magenta') meta.currency-=10; meta.purchases.skin='magenta'; } break;

        case 'b_classic': meta.purchases.bulletSkin='classic'; break;
        case 'b_ion':     if(meta.purchases.bulletSkin==='ion' || meta.currency>=8){ if(meta.purchases.bulletSkin!=='ion') meta.currency-=8; meta.purchases.bulletSkin='ion'; } break;
        case 'b_plasma':  if(meta.purchases.bulletSkin==='plasma' || meta.currency>=8){ if(meta.purchases.bulletSkin!=='plasma') meta.currency-=8; meta.purchases.bulletSkin='plasma'; } break;

        case 'fx_default': meta.purchases.scoreFx='default'; break;
        case 'fx_ember':   if(meta.purchases.scoreFx==='ember' || meta.currency>=6){ if(meta.purchases.scoreFx!=='ember') meta.currency-=6; meta.purchases.scoreFx='ember'; } break;
        case 'fx_ice':     if(meta.purchases.scoreFx==='ice' || meta.currency>=6){ if(meta.purchases.scoreFx!=='ice') meta.currency-=6; meta.purchases.scoreFx='ice'; } break;

        case 'bg_neb': meta.purchases.bgTheme='nebula'; initBackdrop(); break;
        case 'bg_vio': if(meta.purchases.bgTheme==='violet' || meta.currency>=8){ if(meta.purchases.bgTheme!=='violet') meta.currency-=8; meta.purchases.bgTheme='violet'; initBackdrop(); } break;
        case 'bg_amb': if(meta.purchases.bgTheme==='amber' || meta.currency>=8){ if(meta.purchases.bgTheme!=='amber') meta.currency-=8; meta.purchases.bgTheme='amber'; initBackdrop(); } break;

        case 'es_def': meta.purchases.enemySkin='default'; break;
        case 'es_pas': if(meta.purchases.enemySkin==='pastel' || meta.currency>=8){ if(meta.purchases.enemySkin!=='pastel') meta.currency-=8; meta.purchases.enemySkin='pastel'; } break;

        case 'mk_toggle': meta.purchases.multiKillFlair=!meta.purchases.multiKillFlair; break;
        case 'close': state.showStore=false; break;
      }
      saveMeta();
      return true;
    }
  }
  return false;
}
function handleEndScreenClick(px,py){
  const bw=130*DPR, bh=36*DPR, gap=20*DPR, y=H*0.5;
  const rRestart={x:W*0.3-bw/2, y:y, w:bw, h:bh};
  const rRevive={x:W*0.5-bw/2, y:y, w:bw, h:bh};
  const rOptions={x:W*0.7-bw/2, y:y, w:bw, h:bh};
  const rStore  ={x:W*0.4-bw/2, y:y+bh+gap, w:bw, h:bh};
  const rBoard  ={x:W*0.6-bw/2, y:y+bh+gap, w:bw, h:bh};
  if(within(px,py,rRestart.x,rRestart.y,rRestart.w,rRestart.h)){ boot(); return true; }
  if(within(px,py,rRevive.x,rRevive.y,rRevive.w,rRevive.h)){
    if(meta.purchases.sparkOfLife>0){ meta.purchases.sparkOfLife--; saveMeta(); doRevive(true); }
    else if(meta.currency>=50){ meta.currency-=50; saveMeta(); doRevive(false); }
    else { addFloater(W/2, H*0.55, 'Not enough currency', '#ff9b9b'); }
    return true;
  }
  if(within(px,py,rOptions.x,rOptions.y,rOptions.w,rOptions.h)){ state.showOptions=true; return true; }
  if(within(px,py,rStore.x,rStore.y,rStore.w,rStore.h)){ state.showStore=true; return true; }
  if(within(px,py,rBoard.x,rBoard.y,rBoard.w,rBoard.h)){ state.showBoard=true; return true; }
  return false;
}
function doRevive(viaSpark){
  state.gameOver=false; state.lives=1; player.x=W/2; player.y=H/2; player.tx=player.x; player.ty=player.y;
  state.invuln=2500;
  state.enemyShots.length=0;
  addFloater(player.x,player.y,'REVIVE!','#ffd866');
  if(viaSpark){
    // grant max power-ups + temporary boost-all as requested
    state.spreadLevel=2; state.hasteLevel=2; state.boostAllT=Math.max(state.boostAllT, 4000);
    addFloater(player.x,player.y+16*DPR,'Spark Bonus!','#ffd866');
  }
}

// ===== Bonus level =====
function triggerBonusLevel(){ state.bonusMode=true; state.bonusT=7000; dropBanner('Bonus Level!'); }

// ===== Boot =====
function boot(){
  resize();
  Object.assign(state, {
    time:0, shake:0, hitstop:0, score:0, displayScore:0, scorePulse:0,
    lives:3, wave:1, gameOver:false, lastSpawn:0, spawnDelay:650, waveTarget:12, spawned:0,
    lastShot:0, shootDelay:380, bombs:1, invuln:0,
    spreadLevel:0, hasteLevel:0, mult:1, multTimer:0, geomCapReached:false, tempMultBoost:0,
    banner:{text:'',t:0}, joy:{active:false,ox:0,oy:0,x:0,y:0,a:0,t:0},
    cometTimer: rand(8000,16000), bgPulse:0,
    enemySlowT:0, magnetT:0, boostAllT:0,
    combo:0, comboT:0, comboWindow:1100, grazes:0, lastComboAwarded:0,
    lostLifeThisWave:false,
    showStart:true, hasMoved:false, showOptions:false, showStore:false, showBoard:false,
    aimMode: state.aimMode, inputMode: state.inputMode, muted: state.muted,
    bonusMode:false, bonusT:0, pbNotified:false
  });
  state.enemies.length=0; state.bullets.length=0; state.enemyShots.length=0; state.trails.length=0; state.floaters.length=0; state.ripples.length=0; state.particles.length=0; state.powerups.length=0; state.comets.length=0;
  player.r=16*DPR; player.speed=0.38*DPR; player.x=W/2; player.y=H/2; player.tx=player.x; player.ty=player.y; player.shielded=false;
  if(meta.purchases.skin==='lime') player.color='#b0ff9b'; else if(meta.purchases.skin==='magenta') player.color='#ff7ad1'; else player.color='#00ffcc';
  dropBanner('Wave 1'); spawnEnemy(); spawnEnemy();
  let last=performance.now();
  function loop(now){ try{ requestAnimationFrame(loop); const dt=Math.min(50, now-last); last=now; update(dt,now); draw(); }catch(err){ showError(err); } }
  requestAnimationFrame(loop);
}
boot();
</script>

<script>
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('./sw.js?v=ztap-arena-v5')
    .then(() => console.log("✅ Service Worker registered"))
    .catch(err => console.warn("SW registration failed:", err));
}
</script>

</body>
</html>
