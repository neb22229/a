<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>ZTap-Arena — Deep-Space Nebula+ v5</title>
<style>
  html,body{margin:0;height:100%;background:#06080f;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;color:#e6f0ff}
  canvas{display:block;width:100vw;height:100vh;touch-action:none;cursor:crosshair}
</style>
</head>
<body>
<canvas id="game"></canvas>
<script>
// =========================
// ZTap-Arena — Deep-Space Nebula+ v5
// - Seamless start with drag prompt + bottom buttons
// - Options overlay (control mode, aim mode, mute placeholder)
// - UI icons (bombs, lives, currency)
// - Enemy color-consistent explosions
// - New pickups: hp, magnet, multBoost, multiBomb, boostAll, slow
// - Permanent Shield (until hit), Haste acts like Spread (level-based)
// - Points for pickups (bonus if maxed)
// - Combo meter + Multi-kill popups + near-miss dopamine
// - Brute enemy with HP ring; scaling HP rings for basics on later waves
// - Harder enemies worth more points
// - Score milestones + Personal Best + currency drop/persist
// - End screen with Restart + Revive (uses currency)
// (Bonus level + store + leaderboard are scaffolded with TODO hooks)
// =========================

// ===== Canvas setup =====
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d', { alpha:false });
const isMobile = /Mobi|Android|iPhone/i.test(navigator.userAgent);
let W=1,H=1,DPR=1,UIS=1;
function resize(){
  const vw = Math.max(1, document.documentElement.clientWidth || innerWidth || 320);
  const vh = Math.max(1, document.documentElement.clientHeight || innerHeight || 240);
  DPR = isMobile ? Math.min(2, (window.devicePixelRatio||1)) : (window.devicePixelRatio||1);
  W = (vw*DPR)|0; H = (vh*DPR)|0; canvas.width=W; canvas.height=H; canvas.style.width=vw+'px'; canvas.style.height=vh+'px';
  UIS = Math.min(1, Math.max(0.8, Math.min(vw,vh)/720));
  initBackdrop();
}
addEventListener('resize', resize, {passive:true});

function showError(msg){ try{ ctx.setTransform(1,0,0,1,0,0); ctx.fillStyle='#220'; ctx.fillRect(0,0,W,H); ctx.fillStyle='#fbb'; ctx.fillText('⚠ '+String(msg).slice(0,200), 10*DPR, 20*DPR);}catch(_){} }
addEventListener('error',e=>showError(e.message||e.error));
addEventListener('unhandledrejection',e=>showError(e.reason));

// ===== Persistence (PB + currency + options) =====
const store = {
  get(key, fallback){ try{ const v = localStorage.getItem(key); return v!==null ? JSON.parse(v) : fallback; }catch(_){ return fallback; } },
  set(key, val){ try{ localStorage.setItem(key, JSON.stringify(val)); }catch(_){} }
};
const persist = {
  currency: store.get('ztap_currency', 0),
  best: store.get('ztap_best', 0),
  opts: store.get('ztap_opts', { control:'drag', aim:'nearest', muted:false })
};
function savePersist(){ store.set('ztap_currency', persist.currency); store.set('ztap_best', persist.best); store.set('ztap_opts', persist.opts); }

// ===== Game state =====
const state={
  mode:'start', // start, play, gameover, bonus
  time:0, shake:0, hitstop:0,
  score:0, displayScore:0, scorePulse:0,
  lives:3, wave:1, gameOver:false,
  enemies:[], bullets:[], enemyShots:[],
  // Background layers
  stars:[], nebula:[], galaxies:[], comets:[],
  trails:[], ripples:[], floaters:[], particles:[], powerups:[],
  lastSpawn:0, spawnDelay:650, waveTarget:12, spawned:0,
  lastShot:0, shootDelay:380,
  activePointers:new Set(), lastTapTime:0, lastTapX:0, lastTapY:0,
  bombs:1,
  invuln:0, // spawn protection timer only
  shield:false, // true until hit
  spreadLevel:0,
  hasteLevel:0, // permanent, like spread
  // temporary effects
  slowTimer:0, boostAllTimer:0, multBoostTimer:0,
  mult:1, multTimer:0, multCap:3, geomCapReached:false,
  banner:{text:'',t:0},
  joy:{ active:false, ox:0, oy:0, x:0, y:0, a:0, t:0 },
  // Background fx controls
  cometTimer: 0, bgPulse: 0,
  // UI overlay
  showOptions:false, showBottomUI:true, // bottom UI fades after first move
  // Combo & skill feedback
  recentKills:[], combo:0, comboTimer:0, nearMissTimer:0,
  // Currency/milestones
  currency: persist.currency, best: persist.best, toldNewBest:false, milestones:{5000:false,10000:false,20000:false,50000:false},
  // Options
  control: persist.opts.control, // 'drag' | 'tap' | 'both'
  aim: persist.opts.aim,         // 'nearest' | 'directional'
  muted: persist.opts.muted
};
const player={ x:0,y:0, tx:0,ty:0, r:16, speed:0.38, color:'#00ffcc', lastMoveT:0, mvx:0, mvy:0 };

// ===== Utils =====
const rand=(a,b)=>a+Math.random()*(b-a);
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const dist=(a,b)=>Math.hypot(a.x-b.x,a.y-b.y);
const nowMs=()=>performance.now();
// segment vs circle (for bullet sweep tests)
function segHitsCircle(x1,y1,x2,y2,cx,cy,r){
  const dx=x2-x1, dy=y2-y1; const a=dx*dx+dy*dy;
  if(a===0){ return Math.hypot(cx-x1, cy-y1) <= r; }
  let t=((cx-x1)*dx + (cy-y1)*dy)/a; if(t<0) t=0; else if(t>1) t=1;
  const px=x1 + dx*t, py=y1 + dy*t; return Math.hypot(px-cx,py-cy) <= r;
}
function drawStar(x,y,points,outerR,innerR,rot){ ctx.beginPath(); rot=rot||-Math.PI/2; const step=Math.PI/points; for(let i=0;i<points*2;i++){ const r=(i%2===0? outerR:innerR); const a=rot+i*step; const sx=x+Math.cos(a)*r, sy=y+Math.sin(a)*r; i?ctx.lineTo(sx,sy):ctx.moveTo(sx,sy);} ctx.closePath(); }
function lerp(a,b,t){ return a+(b-a)*t; }
function sign(x){ return x<0?-1:1; }

// ===== Backdrop init (stars + nebula + galaxies) =====
function initBackdrop(){
  // Stars
  const starCount=Math.max(90,Math.floor((W*H)/11000)); const stars=[];
  for(let i=0;i<starCount;i++) stars.push({x:Math.random()*W,y:Math.random()*H,z:Math.random()<0.6?0.5:1,tw:Math.random()*6});
  state.stars=stars;

  // Nebula blobs (richer palette)
  const N = [];
  const base = [
    {x:W*0.30,y:H*0.35,r:120*DPR,color:'rgba(100,160,255,0.10)'} , // blue
    {x:W*0.72,y:H*0.62,r:160*DPR,color:'rgba(100,160,255,0.08)'} , // blue
  ];
  const extra = [ // purple / orange / teal accents
    {x:W*rand(0.2,0.4), y:H*rand(0.2,0.5), r:rand(90,150)*DPR, color:'rgba(190,110,255,0.16)'},
    {x:W*rand(0.6,0.85), y:H*rand(0.45,0.8), r:rand(120,180)*DPR, color:'rgba(255,170,90,0.14)'},
    {x:W*rand(0.35,0.65), y:H*rand(0.15,0.4), r:rand(100,160)*DPR, color:'rgba(90,230,220,0.16)'}
  ];
  [...base, ...extra].forEach((n,i)=>{ N.push({x:n.x,y:n.y,r:n.r,baseR:n.r, color:n.color, phase:rand(0,Math.PI*2), speed:rand(0.0007,0.0012)}); });
  state.nebula = N;

  // Galaxies (parallax + slow rotation)
  const G=[];
  const makeGalaxy=(z)=>({
    x: rand(W*0.15, W*0.85), y: rand(H*0.15, H*0.85),
    z, rot: rand(0,Math.PI*2), rotSpeed: rand(0.0002,0.0005),
    rx: rand(160,260)*DPR, ry: rand(80,160)*DPR,
    hue: rand(180,330) // colorful range
  });
  G.push(makeGalaxy(0.35)); G.push(makeGalaxy(0.6));
  state.galaxies = G;

  // schedule next comet
  state.cometTimer = rand(12000, 22000);
}

// ===== Background draw =====
function waveGradient(){
  return ['#0b1020','#05070a'];
}
function drawBackground(){
  const pulse = Math.max(0, state.bgPulse||0); const boost = 1 + 0.5*pulse;
  const [c0,c1] = waveGradient();
  const g=ctx.createRadialGradient(W/2,H/2,0,W/2,H/2,Math.max(W,H)/1.05);
  g.addColorStop(0, c0);
  g.addColorStop(0.55, '#0f1730');
  g.addColorStop(1, c1);
  ctx.fillStyle=g; ctx.fillRect(0,0,W,H);

  // far galaxies
  ctx.save();
  for(const gal of state.galaxies){
    const parx=(player.x-W/2)*0.00025*(gal.z*60), pary=(player.y-H/2)*0.00025*(gal.z*60);
    const x=((gal.x + parx) % W + W)%W, y=((gal.y + pary) % H + H)%H;
    ctx.save(); ctx.translate(x,y); ctx.rotate(gal.rot);
    ctx.scale(gal.rx, gal.ry);
    const rg=ctx.createRadialGradient(0,0,0,0,0,1);
    const h=gal.hue;
    rg.addColorStop(0, `hsla(${h},80%,70%,${0.12*boost})`);
    rg.addColorStop(0.4, `hsla(${(h+40)%360},90%,60%,${0.09*boost})`);
    rg.addColorStop(1, 'hsla(0,0%,0%,0)');
    ctx.fillStyle=rg; ctx.beginPath(); ctx.arc(0,0,1,0,Math.PI*2); ctx.fill();
    ctx.restore();
  }
  ctx.restore();

  // nebula blobs
  ctx.save(); ctx.globalCompositeOperation='lighter';
  for(let i=0;i<state.nebula.length;i++){
    const n=state.nebula[i];
    const r = n.baseR * (1.1 + 0.2*Math.sin((state.time*n.speed)+n.phase));
    const grd=ctx.createRadialGradient(n.x,n.y,0,n.x,n.y,r);
    grd.addColorStop(0, n.color);
    grd.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle=grd; ctx.beginPath(); ctx.arc(n.x,n.y,r*1.15,0,Math.PI*2); ctx.fill();
  }
  ctx.restore();

  // parallax stars
  ctx.save(); ctx.globalAlpha=0.98; for(const s of state.stars){ const r=(s.z===1?1.9:1.1)*DPR; ctx.beginPath(); ctx.arc(s.x,s.y,r,0,Math.PI*2); ctx.fillStyle=s.z===1?'#20508a':'#153252'; ctx.fill(); if((s.tw%6)<0.26){ ctx.beginPath(); ctx.arc(s.x,s.y,r*1.7,0,Math.PI*2); ctx.globalAlpha=0.18; ctx.fillStyle='#8bd0ff'; ctx.fill(); ctx.globalAlpha=0.98; } } ctx.restore();
  // neon grid
  const cell=Math.max(28,40*DPR*UIS); ctx.globalAlpha=0.12; ctx.beginPath(); const t2=state.time*0.00025; for(let x=((t2*60)%cell)-cell; x<W; x+=cell){ ctx.moveTo(x,0); ctx.lineTo(x,H);} for(let y=((t2*40)%cell)-cell; y<H; y+=cell){ ctx.moveTo(0,y); ctx.lineTo(W,y);} ctx.strokeStyle='#0e1a2c'; ctx.lineWidth=1; ctx.stroke(); ctx.globalAlpha=1;

  // comets
  ctx.save();
  for(const c of state.comets){
    ctx.globalCompositeOperation='lighter';
    const trail = Math.max(10*DPR, c.len*0.6);
    const ang = Math.atan2(c.vy, c.vx);
    ctx.save(); ctx.translate(c.x, c.y); ctx.rotate(ang);
    const cg = ctx.createLinearGradient(-trail,0,0,0);
    cg.addColorStop(0, 'rgba(124,195,255,0)');
    cg.addColorStop(1, 'rgba(124,195,255,0.9)');
    ctx.fillStyle=cg; ctx.beginPath(); ctx.ellipse(-trail/2, 0, trail/2, 2*DPR, 0, 0, Math.PI*2); ctx.fill();
    ctx.globalAlpha=1; ctx.beginPath(); ctx.arc(0,0, 2.2*DPR, 0, Math.PI*2); ctx.fillStyle='#e6f9ff'; ctx.fill();
    ctx.restore();
  }
  ctx.restore();
}

// ===== Enemy palette + points =====
const ENEMY_META={
  grunt:   {color:'#7a4cff', points:10, hp:1},
  weaver:  {color:'#ff7ad1', points:12, hp:1},
  orbiter: {color:'#7affd1', points:14, hp:1},
  charger: {color:'#ff6b6b', points:16, hp:1},
  shooter: {color:'#6bffb0', points:20, hp:1},
  brute:   {color:'#ffd866', points:30, hp:4},
};
function enemyColor(e){ return ENEMY_META[e.type]?.color || '#7a4cff'; }
function enemyPoints(e){ // harder enemies worth more, wave scales tiny
  const base = ENEMY_META[e.type]?.points || 10;
  return Math.round(base + Math.min(10, state.wave*0.6));
}

// ===== Spawning: full enemy set =====
function pickEnemyType(){
  const w=state.wave, pool=[]; const push=(t,n)=>{for(let i=0;i<n;i++) pool.push(t)};
  push('grunt',8);
  if(w>=2) push('weaver', Math.min(5, 1+Math.floor(w/2)));
  if(w>=3) push('charger',Math.min(3,Math.floor((w-2)/2)));
  if(w>=4) push('orbiter',Math.min(3,Math.floor((w-3)/2)));
  if(w>=5) push('shooter',Math.min(2,Math.floor((w-4)/2)));
  if(w>=6) push('brute',Math.min(1+Math.floor((w-5)/3), 3));
  return pool[Math.floor(Math.random()*pool.length)]||'grunt';
}
function spawnEnemy(forceType){
  const m=24*DPR; const edge=(Math.random()*4)|0; let x,y;
  if(edge===0){x=rand(m,W-m);y=-m;} else if(edge===1){x=W+m;y=rand(m,H-m);} else if(edge===2){x=rand(m,W-m);y=H+m;} else {x=-m;y=rand(m,H-m);}
  let type=forceType||pickEnemyType(); if(!forceType && state.wave>=2 && (state.spawned % 3 === 0)) type='weaver';
  const common={x,y,px:x,py:y,t:0, alive:true, type, hp:(ENEMY_META[type]?.hp||1)};
  if(type==='grunt')   state.enemies.push({...common,r:12*DPR,speed:rand(0.08,0.12)*DPR});
  else if(type==='weaver') state.enemies.push({...common,r:11*DPR,speed:rand(0.08,0.11)*DPR,sway:rand(0.003,0.006),phase:rand(0,Math.PI*2),tail:[]});
  else if(type==='orbiter') state.enemies.push({...common,r:12*DPR,angle:rand(0,Math.PI*2),radius:rand(70,110)*DPR});
  else if(type==='charger') state.enemies.push({...common,r:12*DPR,speed:0.09*DPR,phase:'aim',wind:320,vx:0,vy:0,dashSpeed:0.5*DPR});
  else if(type==='shooter') state.enemies.push({...common,r:12*DPR,speed:0.06*DPR,desired:rand(160,220)*DPR,fireCD:rand(700,1000)});
  else if(type==='brute')   state.enemies.push({...common,r:14*DPR,speed:0.07*DPR});
  state.spawned++;
}
function nextWave(){
  // reward bonus if no death this wave
  if(state.livesWaveLoss===0){
    const bonus = 50 + Math.round(state.wave*10);
    state.score += bonus;
    addFloater(player.x, player.y - 24*DPR, `No-Death +${bonus}`);
  }
  state.wave++; state.waveTarget+=5; state.spawned=0; state.lastSpawn=0;
  state.lastWaveLife = state.lives;
  state.livesWaveLoss = 0;
  state.spawnDelay=Math.max(260,state.spawnDelay*0.9);
  state.shootDelay=Math.max(300,state.shootDelay*0.96);
  dropBanner(`Wave ${state.wave}`);
  // late waves: occasionally give HP ring to basics
  // wave comet
  state.cometTimer = Math.min(state.cometTimer, 800);
}

// ===== FX & helpers =====
function addFloater(x,y,text, col){ state.floaters.push({x,y,text,a:1,vy:-0.05*DPR,col:col||'#fff'}); }
function addBurst(x,y,n=16,col='#6bbcff'){ for(let i=0;i<n;i++){ const a=Math.random()*Math.PI*2, s=rand(0.6,2.0)*DPR; state.particles.push({x,y,vx:Math.cos(a)*s,vy:Math.sin(a)*s,r:rand(1,3)*DPR,a:1,col}); } }
function dropBanner(text){ state.banner.text=text; state.banner.t=1400; }
function killImpact(x,y){ state.hitstop=Math.max(state.hitstop,60); state.ripples.push({x,y,r:10*DPR,max:100*DPR,a:0.9}); }
function spawnPowerup(type,x,y){ state.powerups.push({type,x,y,t:0,r:11*DPR,a:1}); }
function awardCurrency(amount, where){ if(amount<=0) return; state.currency += amount; addFloater(where?.x||W-40*DPR, where?.y||40*DPR, `¤+${amount}`, '#ffd866'); }

// ===== Combat =====
function getAimAngle(){
  if(state.aim==='directional'){
    const vx = player.mvx, vy = player.mvy;
    if(Math.hypot(vx,vy) < 0.001) return 0;
    return Math.atan2(vy, vx);
  }else{
    const e=getNearestEnemy(); if(!e) return null;
    return Math.atan2(e.y-player.y, e.x-player.x);
  }
}
function getNearestEnemy(){ let best=Infinity, pick=null; for(const e of state.enemies){ if(!e.alive) continue; const d=Math.hypot(e.x-player.x,e.y-player.y); if(d<best){best=d; pick=e;} } return pick; }
function shoot(now){
  const hasteFactor = 1 / (1 + 0.2*state.hasteLevel); // each level ~20% faster
  if(now-state.lastShot < state.shootDelay*hasteFactor) return;
  const ang = getAimAngle(); if(ang===null) return;
  const speed=8*DPR; const level=state.spreadLevel;
  const angles= level===0?[0]:(level===1?[-0.12,0,0.12]:[-0.21,-0.09,0,0.09,0.21]);
  for(const off of angles){
    const a=ang+off;
    state.bullets.push({x:player.x,y:player.y, px:player.x,py:player.y, vx:Math.cos(a)*speed, vy:Math.sin(a)*speed, r:3*DPR, life:900});
  }
  state.lastShot=now;
}
function detonateBomb(){
  if(state.bombs<=0||state.gameOver) return;
  state.bombs--;
  let killed = 0;
  for(const e of state.enemies){
    if(e.alive){
      const col = enemyColor(e);
      e.alive = false;
      addBurst(e.x,e.y, (e.type==='charger'||e.type==='shooter'||e.type==='orbiter'||e.type==='brute') ? 28 : 18, col);
      const pts = enemyPoints(e) * state.mult;
      state.score += pts;
      killed++;
    }
  }
  state.enemyShots.length = 0;
  state.shake += Math.min(24*DPR, 8*DPR + killed*0.7*DPR);
  killImpact(player.x,player.y);
  addFloater(player.x,player.y,'BOMB!','#ffae6b');
  state.bgPulse = 1.0;
}

// ===== Input (drag + bombs + joystick + start/buttons) =====
function canvasToPx(e){
  const rect=canvas.getBoundingClientRect();
  const px=clamp((e.clientX-rect.left)*DPR,0,W);
  const py=clamp((e.clientY-rect.top)*DPR,0,H);
  return {px,py};
}
function onPointerDown(e){
  const {px,py}=canvasToPx(e);
  if(state.mode==='start'){
    // Bottom bar buttons: options / store / leaderboard
    if(hitButton(px,py, startButtons.options)) { state.showOptions = !state.showOptions; return; }
    if(hitButton(px,py, startButtons.store))   { dropBanner('Store — coming soon'); return; }
    if(hitButton(px,py, startButtons.leader)) { dropBanner('Leaderboard — coming soon'); return; }
    // any drag starts the game
    state.mode='play'; state.showBottomUI=false;
    player.tx=px; player.ty=py;
  } else if(state.mode==='gameover'){
    if(hitButton(px,py, endButtons.restart)){ boot(true); return; }
    if(hitButton(px,py, endButtons.revive)){ tryRevive(); return; }
    if(hitButton(px,py, startButtons.options)) { state.showOptions = !state.showOptions; return; }
  } else {
    // gameplay: bombs (two fingers or double tap near)
    state.activePointers.add(e.pointerId);
    if(state.control!=='tap'){
      // drag style
      player.tx=px; player.ty=py;
      if(state.activePointers.size===1){ state.joy.active=true; state.joy.ox=px; state.joy.oy=py; state.joy.x=px; state.joy.y=py; state.joy.a=1; state.joy.t=0; }
    }else{
      // tap-to-move: teleport target
      player.tx=px; player.ty=py;
    }
    if(state.activePointers.size>=2 && state.bombs>0){ detonateBomb(); return; }
    const now=performance.now(); const dt=now-state.lastTapTime; const near=Math.hypot(px-state.lastTapX,py-state.lastTapY)<20*DPR;
    if(dt<300 && near && state.bombs>0){ detonateBomb(); }
    state.lastTapTime=now; state.lastTapX=px; state.lastTapY=py;
  }
}
function onPointerMove(e){
  if(!state.activePointers.has(e.pointerId)) return;
  const {px,py}=canvasToPx(e);
  player.tx=px; player.ty=py; state.joy.x=px; state.joy.y=py; state.joy.a=Math.min(1, state.joy.a + 0.02);
}
function onPointerUp(e){
  state.activePointers.delete(e.pointerId);
  if(state.activePointers.size===0){ state.joy.active=false; }
}
canvas.addEventListener('pointerdown', onPointerDown, {passive:true});
canvas.addEventListener('pointermove', onPointerMove, {passive:true});
canvas.addEventListener('pointerup', onPointerUp, {passive:true});
canvas.addEventListener('pointercancel', onPointerUp, {passive:true});

// ===== Buttons (canvas UI) =====
function button(x,y,w,h,label){ return {x,y,w,h,label}; }
function hitButton(px,py,b){ return b && px>=b.x && px<=b.x+b.w && py>=b.y && py<=b.y+b.h; }
const startButtons = {
  options: { get x(){ return 10*DPR; }, get y(){ return H-40*DPR; }, get w(){ return 80*DPR; }, get h(){ return 28*DPR; }, label:'⚙︎' },
  store:   { get x(){ return 100*DPR; }, get y(){ return H-40*DPR; }, get w(){ return 80*DPR; }, get h(){ return 28*DPR; }, label:'🛒' },
  leader:  { get x(){ return 190*DPR; }, get y(){ return H-40*DPR; }, get w(){ return 80*DPR; }, get h(){ return 28*DPR; }, label:'🏆' },
};
const endButtons = {
  restart: { get x(){ return W/2 - 120*DPR; }, get y(){ return H/2 + 40*DPR; }, get w(){ return 100*DPR; }, get h(){ return 30*DPR; }, label:'↻ Restart' },
  revive:  { get x(){ return W/2 +  20*DPR; }, get y(){ return H/2 + 40*DPR; }, get w(){ return 100*DPR; }, get h(){ return 30*DPR; }, label:'♥ Revive' },
};

// ===== Update =====
function update(dt,now){
  const ts=(state.hitstop>0||state.gameOver)?0.25:1; state.hitstop=Math.max(0,state.hitstop-dt);
  state.time += dt*ts;
  if(state.mult>1){ state.multTimer=Math.max(0,state.multTimer-dt); if(state.multTimer<=0){ state.mult=1; }}
  if(state.multBoostTimer>0){ state.multBoostTimer-=dt; if(state.multBoostTimer<=0){ /* natural decay handled by multTimer*/ } }
  state.displayScore += (state.score-state.displayScore)*0.18;
  state.invuln=Math.max(0,state.invuln-dt);
  state.slowTimer=Math.max(0,state.slowTimer-dt);
  state.boostAllTimer=Math.max(0,state.boostAllTimer-dt);
  state.joy.t += dt; state.joy.a = state.joy.active ? Math.min(1, state.joy.a + dt*0.004) : Math.max(0, state.joy.a - dt*0.0035);
  state.bgPulse = Math.max(0, state.bgPulse - dt*0.0012);
  state.comboTimer = Math.max(0, state.comboTimer - dt);
  if(state.comboTimer<=0) state.combo = Math.max(0, state.combo - 1);

  // galaxies slow rotation
  for(const gal of state.galaxies){ gal.rot += gal.rotSpeed*dt; }

  // parallax stars drift
  const ox=(player.x-W/2)*0.00025, oy=(player.y-H/2)*0.00025;
  for(const s of state.stars){ s.x+=ox*(s.z===1?14:7); s.y+=oy*(s.z===1?14:7); if(s.x<0)s.x+=W; if(s.x>W)s.x-=W; if(s.y<0)s.y+=H; if(s.y>H)s.y-=H; s.tw+=dt*0.01; }
  for(let i=0;i<state.nebula.length;i++){ const n=state.nebula[i]; n.x += Math.sin((state.time*0.0001)+i)*0.1*DPR; n.y += Math.cos((state.time*0.00008)+i)*0.08*DPR; }

  // comet spawner
  state.cometTimer -= dt; if(state.cometTimer<=0){
    const edge = (Math.random()*4)|0; let x,y,vx,vy; const speed = rand(0.25,0.45)*DPR; const angJitter = rand(-0.25,0.25);
    if(edge===0){ x=-20*DPR; y=rand(0,H); const ang = 0+angJitter; vx=Math.cos(ang)*speed; vy=Math.sin(ang)*speed; }
    else if(edge===1){ x=W+20*DPR; y=rand(0,H); const ang = Math.PI+angJitter; vx=Math.cos(ang)*speed; vy=Math.sin(ang)*speed; }
    else if(edge===2){ x=rand(0,W); y=-20*DPR; const ang = Math.PI/2+angJitter; vx=Math.cos(ang)*speed; vy=Math.sin(ang)*speed; }
    else { x=rand(0,W); y=H+20*DPR; const ang = -Math.PI/2+angJitter; vx=Math.cos(ang)*speed; vy=Math.sin(ang)*speed; }
    state.comets.push({x,y,vx,vy,life:rand(900,1400),len:rand(50,110)});
    const base = rand(12000, 22000); const bonus = Math.max(0, 5000 - state.wave*400); state.cometTimer = Math.max(6000, base - bonus);
  }
  for(const c of state.comets){ c.x+=c.vx*dt; c.y+=c.vy*dt; c.life-=dt; }
  state.comets = state.comets.filter(c=> c.life>0 && c.x>-50 && c.x<W+50 && c.y>-50 && c.y<H+50);

  // player movement & trail
  state.trails.push({x:player.x,y:player.y,r:player.r,a:0.5});
  state.trails=state.trails.filter(t=>(t.a-=0.02)>0);
  const dxp=player.tx-player.x, dyp=player.ty-player.y, lp=Math.hypot(dxp,dyp);
  if(lp>0.1){
    const slow = (state.slowTimer>0)? 0.7 : 1;
    const step=Math.min(lp,player.speed*dt*ts*slow);
    const vx=(dxp/lp)*step, vy=(dyp/lp)*step;
    player.x+=vx; player.y+=vy;
    // track movement vector (for directional aim)
    player.mvx = vx; player.mvy = vy;
    player.lastMoveT = now;
  }

  if(state.mode!=='play') return;

  // spawns
  state.lastSpawn+=dt*ts; if(state.spawned<state.waveTarget && state.lastSpawn>state.spawnDelay){ spawnEnemy(); state.lastSpawn=0; }

  // enemies
  for(const e of state.enemies){
    if(!e.alive) continue; e.px=e.x; e.py=e.y; e.t+=dt*ts;
    const slowMul = (state.slowTimer>0)? 0.75 : 1;
    if(e.type==='grunt'){
      const dx=player.x-e.x, dy=player.y-e.y, l=Math.hypot(dx,dy)||1; e.x+=(dx/l)*e.speed*dt*ts*slowMul; e.y+=(dy/l)*e.speed*dt*ts*slowMul;
    } else if(e.type==='weaver'){
      const dx=player.x-e.x, dy=player.y-e.y, l=Math.hypot(dx,dy)||1; const nx=dx/l, ny=dy/l; const sx=-ny, sy=nx; const wiggle=Math.sin(e.t*e.sway+e.phase)*0.8; e.x+=(nx*e.speed+sx*e.speed*wiggle)*dt*ts*slowMul; e.y+=(ny*e.speed+sy*e.speed*wiggle)*dt*ts*slowMul; e.tail=e.tail||[]; const last=e.tail[e.tail.length-1]; if(!last || Math.hypot(e.x-last.x,e.y-last.y)>2.5*DPR){ e.tail.push({x:e.x,y:e.y}); if(e.tail.length>40) e.tail.shift(); }
    } else if(e.type==='orbiter'){
      e.angle=(e.angle||0)+0.0028*dt*ts*slowMul; e.x=player.x+Math.cos(e.angle)*e.radius; e.y=player.y+Math.sin(e.angle)*e.radius;
    } else if(e.type==='charger'){
      if(e.phase==='aim'){
        const dx=player.x-e.x,dy=player.y-e.y,l=Math.hypot(dx,dy)||1; e.x+=(dx/l)*e.speed*dt*ts*slowMul; e.y+=(dy/l)*e.speed*dt*ts*slowMul; e.wind-=dt*ts;
        if(e.wind<=0){ const dx2=player.x-e.x,dy2=player.y-e.y,L=Math.hypot(dx2,dy2)||1; e.vx=(dx2/L)*e.dashSpeed; e.vy=(dy2/L)*e.dashSpeed; e.phase='dash'; e.dashT=260; }
      } else { e.x+=e.vx*dt*ts*slowMul; e.y+=e.vy*dt*ts*slowMul; e.dashT-=dt*ts; if(e.dashT<=0){ e.phase='aim'; e.wind=380; } }
    } else if(e.type==='shooter'){
      const dx=player.x-e.x,dy=player.y-e.y,l=Math.hypot(dx,dy)||1; const nx=dx/l,ny=dy/l; let mx=0,my=0; const ideal=e.desired; const d=l;
      if(d<ideal*0.9){ mx-=nx*e.speed*dt*ts*slowMul; my-=ny*e.speed*dt*ts*slowMul; }
      else if(d>ideal*1.1){ mx+=nx*e.speed*dt*ts*slowMul; my+=ny*e.speed*dt*ts*slowMul; }
      else { mx+=-ny*e.speed*0.6*dt*ts*slowMul; my+=nx*e.speed*0.6*dt*ts*slowMul; }
      e.x+=mx; e.y+=my; e.fireCD-=dt*ts; if(e.fireCD<=0){ const sx=(dx/l)*2.6*DPR, sy=(dy/l)*2.6*DPR; state.enemyShots.push({x:e.x,y:e.y,vx:sx,vy:sy,r:3*DPR,life:1800}); e.fireCD=rand(700,1100); }
    } else if(e.type==='brute'){
      const dx=player.x-e.x, dy=player.y-e.y, l=Math.hypot(dx,dy)||1; e.x+=(dx/l)*e.speed*dt*ts*slowMul; e.y+=(dy/l)*e.speed*dt*ts*slowMul;
    }
    // collision with player
    if(Math.hypot(e.x-player.x,e.y-player.y) < (e.r+player.r)){
      if(state.invuln<=0 && !state.shield){
        e.alive=false; addBurst(player.x,player.y,24, '#ff6b6b'); state.shake=8*DPR; state.mult=1; state.multTimer=0; state.geomCapReached=false; state.scorePulse=1; state.enemyShots.length=0; state.enemies.length=0;
        state.lives--; state.livesWaveLoss = (state.livesWaveLoss||0) + 1;
        if(state.lives>0){ respawnCenter(); } else { gameOver(); }
      } else {
        // shield absorbs
        e.alive=false; addBurst(e.x,e.y,18, enemyColor(e)); state.shield=false; addFloater(player.x,player.y,'Shield Broken','#6bffea');
        state.invuln = Math.max(state.invuln, 800); // brief i-frames after shield pop
      }
    }
  }
  state.enemies = state.enemies.filter(e=>e.alive);

  // bullets -> enemies
  for(const b of state.bullets){ b.px=b.x; b.py=b.y; b.x+=b.vx*ts; b.y+=b.vy*ts; b.life-=dt*ts; }
  for(const b of state.bullets){
    if(b.life<=0) continue;
    for(const e of state.enemies){
      if(!e.alive) continue;
      const R = e.r + b.r + 1.5*DPR;
      const hit = ( segHitsCircle(b.px,b.py,b.x,b.y, e.x,e.y, R) ||
                    segHitsCircle(b.px,b.py,b.x,b.y, (e.px||e.x), (e.py||e.y), R) ||
                    segHitsCircle(b.px,b.py,b.x,b.y, ((e.x+(e.px||e.x))*0.5), ((e.y+(e.py||e.y))*0.5), R) );
      if(hit){
        b.life=0;
        e.hp -= 1;
        if(e.hp<=0){
          e.alive=false;
          const col = enemyColor(e);
          const big=(e.type==='charger'||e.type==='shooter'||e.type==='orbiter'||e.type==='brute');
          addBurst(e.x,e.y,big?28:16, col);
          const pts = enemyPoints(e) * state.mult;
          state.score += pts; state.scorePulse=1;
          addFloater(e.x,e.y,'+'+pts, '#b0ff9b');
          state.shake+=big?6*DPR:3*DPR;
          // combo
          state.recentKills.push(now); state.combo+=1; state.comboTimer=1600;
          // drops
          handleDrops(e);
          if(big) killImpact(e.x,e.y);
        }else{
          // on hit feedback
          addFloater(e.x, e.y-10*DPR, '•', '#ffd866');
        }
        break;
      }
    }
  }
  state.bullets = state.bullets.filter(b=>b.life>0);

  // enemy bullets -> player
  for(const s of state.enemyShots){ s.x+=s.vx*ts; s.y+=s.vy*ts; s.life-=dt*ts;
    // near-miss effect (dopamine): within 1.2x radius but not hit
    const d = Math.hypot(s.x-player.x, s.y-player.y);
    if(d < player.r*1.4 + s.r && d > player.r + s.r){
      if(state.nearMissTimer<=0){
        state.score += 2; addFloater(player.x, player.y-14*DPR, 'Narrow Dodge +2', '#b0ff9b');
        state.nearMissTimer = 400;
      }
    }
  }
  state.nearMissTimer = Math.max(0, state.nearMissTimer - dt);
  for(const s of state.enemyShots){
    if(Math.hypot(s.x-player.x,s.y-player.y)<s.r+player.r){
      if(state.invuln<=0 && !state.shield){
        s.life=0; state.lives--; state.livesWaveLoss = (state.livesWaveLoss||0) + 1;
        addBurst(player.x,player.y,18,'#ff6b6b'); state.shake=8*DPR; state.mult=1; state.multTimer=0; state.geomCapReached=false; state.scorePulse=1; state.enemyShots.length=0; state.enemies.length=0;
        if(state.lives>0){ respawnCenter(); } else { gameOver(); }
      } else {
        s.life=0;
        state.shield=false;
        addFloater(player.x,player.y,'Shield Broken','#6bffea');
        state.invuln = Math.max(state.invuln, 800);
      }
    }
  }
  state.enemyShots = state.enemyShots.filter(s=>s.life>0);

  // powerups motion + magnet
  for(const p of state.powerups){ p.t+=dt*ts; const mag = state.magnetTimer>0 ? 1 : 0;
    if(mag){
      const dx=player.x-p.x, dy=player.y-p.y; const l=Math.hypot(dx,dy)||1;
      p.x += (dx/l) * 0.25*DPR * ts; p.y += (dy/l) * 0.25*DPR * ts;
    }else{
      p.y += Math.sin(p.t*0.003)*0.1*DPR;
    }
  }
  // collect
  for(const p of state.powerups){
    if(Math.hypot(p.x-player.x,p.y-player.y)<player.r+p.r){
      collectPowerup(p);
      p.a=0;
    }
  }
  state.powerups=state.powerups.filter(p=>p.a!==0);

  // ripples/particles/floaters
  for(const r of state.ripples){ r.r+=0.5*DPR*dt/16; r.a-=0.0025*dt; } state.ripples=state.ripples.filter(r=>r.a>0);
  for(const p of state.particles){ p.x+=p.vx*ts; p.y+=p.vy*ts; p.a-=0.02*ts; p.vx*=0.99; p.vy*=0.99; } state.particles=state.particles.filter(p=>p.a>0);
  for(const f of state.floaters){ f.y+=f.vy*ts; f.a-=0.01*ts; } state.floaters=state.floaters.filter(f=>f.a>0);

  // wave progression
  if(state.spawned>=state.waveTarget && state.enemies.length===0){
    // every 10th wave: (TODO) bonus stage stub
    if(state.wave>0 && state.wave%10===0){
      dropBanner('Bonus Stage — coming soon');
    }
    nextWave();
  }
}

function respawnCenter(){
  player.x=W/2; player.y=H/2; player.tx=player.x; player.ty=player.y;
  state.invuln=2500; // spawn protection
  addFloater(player.x,player.y,'-1 LIFE', '#ff6b6b');
}
function gameOver(){
  state.gameOver=true;
  state.mode='gameover';
  dropBanner('GAME OVER');
  // personal best + currency payout
  if(state.score>state.best){ state.best=state.score; state.toldNewBest=true; }
  const pay = Math.round(state.score/80) + Math.min(20, state.wave);
  awardCurrency(pay, {x:W-40*DPR, y:40*DPR});
  persist.currency = state.currency;
  persist.best = state.best;
  savePersist();
}

function handleDrops(e){
  const roll=Math.random();
  const big=(e.type==='charger'||e.type==='shooter'||e.type==='orbiter'||e.type==='brute');
  // currency
  if(roll<0.25){ awardCurrency(1, e); }
  // powerups
  // base chances
  if(roll < 0.03) { spawnPowerup('spread',e.x,e.y); }
  else if(roll < 0.055){ spawnPowerup('haste',e.x,e.y); } // permanent haste
  else if(roll < 0.075){ spawnPowerup('shield',e.x,e.y); }
  else if(roll < 0.095){ spawnPowerup('geom',e.x,e.y); }  // +mult (timed)
  else if(roll < 0.11){ spawnPowerup('hp',e.x,e.y); }
  else if(roll < 0.125){ spawnPowerup('magnet',e.x,e.y); }
  else if(roll < 0.14){ spawnPowerup('multiBomb',e.x,e.y); }
  else if(roll < 0.155){ spawnPowerup('boostAll',e.x,e.y); }
  else if(roll < 0.17){ spawnPowerup('slow',e.x,e.y); }
  else if(big && roll < 0.28){ spawnPowerup('bomb',e.x,e.y); }
  else if(big && roll < 0.30){ spawnPowerup('spread',e.x,e.y); }
}

function collectPowerup(p){
  let points = 5; // base pickup points
  if(p.type==='geom'){
    const prev = state.mult;
    state.mult = Math.min(state.multCap, state.mult+1);
    if(state.mult>=state.multCap){ state.geomCapReached=true; }
    state.multTimer = 6000; // timed
    addFloater(p.x,p.y,'x'+state.mult, '#ffd866');
    state.scorePulse=1;
    if(state.mult===prev) points=15; // already at cap -> bonus points
  } else if(p.type==='bomb'){
    const before = state.bombs; state.bombs=Math.min(9,state.bombs+1);
    addFloater(p.x,p.y,'BOMB+', '#ffae6b');
    if(state.bombs===before) points=20;
  } else if(p.type==='shield'){
    state.shield = true; state.invuln = Math.max(state.invuln, 600); // small glow
    addFloater(p.x,p.y,'SHIELD','#6bffea');
  } else if(p.type==='spread'){
    const before=state.spreadLevel; state.spreadLevel=Math.min(2,state.spreadLevel+1);
    addFloater(p.x,p.y,'SPREAD','#ffd2ff');
    if(state.spreadLevel===before) points=20;
  } else if(p.type==='haste'){
    const before=state.hasteLevel; state.hasteLevel=Math.min(3,state.hasteLevel+1);
    addFloater(p.x,p.y,'HASTE','#7cc3ff');
    if(state.hasteLevel===before) points=20;
  } else if(p.type==='hp'){
    const before=state.lives; state.lives = Math.min(9, state.lives+1);
    addFloater(p.x,p.y,'♥ +1', '#ff6b6b');
    if(state.lives===before) points=25;
  } else if(p.type==='magnet'){
    state.magnetTimer = 6000;
    addFloater(p.x,p.y,'MAGNET','#b0ff9b');
  } else if(p.type==='multiBomb'){
    state.bombs = Math.min(9, state.bombs+2);
    addFloater(p.x,p.y,'BOMBS ++','#ffae6b');
    points += 5;
  } else if(p.type==='boostAll'){
    state.boostAllTimer = 5000;
    // temporarily max spread & haste, grant shield
    state._savedSpread = state._savedSpread ?? state.spreadLevel;
    state._savedHaste  = state._savedHaste  ?? state.hasteLevel;
    state.spreadLevel = 2; state.hasteLevel = Math.max(state.hasteLevel, 2);
    state.shield = true;
    addFloater(p.x,p.y,'ALL BOOST', '#ffd866');
    points += 10;
  } else if(p.type==='slow'){
    state.slowTimer = 5000;
    addFloater(p.x,p.y,'ENEMY SLOW', '#8bd0ff');
    points += 8;
  } else if(p.type==='multBoost'){
    state.mult = Math.min(state.multCap+2, state.mult+2);
    state.multBoostTimer = 4000;
    state.multTimer = Math.max(state.multTimer, 4000);
    addFloater(p.x,p.y,'x'+state.mult, '#ffd866');
    points += 10;
  }
  state.score += points;
}
// decay of temporary "boost all"
function updateBoostAllDecay(){
  if(state.boostAllTimer<=0 && state._savedSpread!=null){
    state.spreadLevel = Math.max(state.spreadLevel, state._savedSpread);
    state.hasteLevel = Math.max(state.hasteLevel, state._savedHaste||0);
    state._savedSpread = null; state._savedHaste = null;
  }
}

// ===== Draw =====
function drawJoystick(){ const j=state.joy; if(!j || j.a<=0) return; const baseR=26*UIS*DPR; const knobR=10*UIS*DPR; const dx=j.x-j.ox, dy=j.y-j.oy; const len=Math.hypot(dx,dy); const cap=48*UIS*DPR; const nx=len>0?dx/len:0, ny=len>0?dy/len:0; const kx=j.ox + nx*Math.min(len,cap); const ky=j.oy + ny*Math.min(len,cap);
  ctx.save(); ctx.globalAlpha=0.35*j.a; ctx.beginPath(); ctx.arc(j.ox,j.oy,baseR,0,Math.PI*2); ctx.fillStyle='#0e1a2c'; ctx.fill(); ctx.lineWidth=2*DPR; ctx.strokeStyle='rgba(124,195,255,0.6)'; ctx.stroke();
  ctx.beginPath(); ctx.moveTo(j.ox,j.oy); ctx.lineTo(kx,ky); ctx.strokeStyle='rgba(124,195,255,0.45)'; ctx.lineWidth=3*DPR; ctx.stroke();
  ctx.globalAlpha=0.8*j.a; ctx.beginPath(); ctx.arc(kx,ky,knobR,0,Math.PI*2); ctx.fillStyle='#7cc3ff'; ctx.shadowColor='#7cc3ff'; ctx.shadowBlur=8*DPR; ctx.fill(); ctx.restore(); }

function drawEnemy(e){
  // tail for weaver
  if(e.type==='weaver' && e.tail){
    ctx.save(); ctx.globalCompositeOperation='lighter'; ctx.shadowColor='#ff7ad1'; ctx.shadowBlur=10*DPR;
    for(let i=0;i<e.tail.length;i++){ const t=e.tail[i]; const a=i/(e.tail.length-1||1); const rSeg = (e.r*0.35) + (e.r*0.95)*a; ctx.globalAlpha=0.06 + 0.6*a; ctx.beginPath(); ctx.arc(t.x,t.y,rSeg,0,Math.PI*2); ctx.fillStyle='#ff7ad1'; ctx.fill(); }
    ctx.restore();
  }
  // body
  ctx.save();
  const color = enemyColor(e);
  ctx.shadowColor=color; ctx.shadowBlur=12*DPR;
  ctx.fillStyle=color; ctx.beginPath(); ctx.arc(e.x,e.y,e.r,0,Math.PI*2); ctx.fill();
  ctx.shadowBlur=0; ctx.strokeStyle='rgba(255,255,255,0.12)'; ctx.lineWidth=2*DPR; ctx.stroke();
  // HP ring for brute or late-wave basics
  const showRing = (e.type==='brute') || (state.wave>=8 && ENEMY_META[e.type]?.hp===1 && Math.random()<0.05);
  if(showRing){
    const maxHp = (e.type==='brute')? ENEMY_META.brute.hp : (e.maxHp||2);
    e.maxHp = e.maxHp || maxHp;
    const ratio = e.hp / e.maxHp;
    ctx.beginPath(); ctx.arc(e.x,e.y,e.r+4*DPR, -Math.PI/2, -Math.PI/2 + Math.PI*2*ratio);
    ctx.strokeStyle='rgba(255,216,102,0.9)'; ctx.lineWidth=2*DPR; ctx.stroke();
  }
  ctx.restore();
}

function draw(){
  ctx.clearRect(0,0,W,H);
  drawBackground();
  ctx.save();
  if(state.shake>0){ ctx.translate((Math.random()*2-1)*state.shake, (Math.random()*2-1)*state.shake); }

  // trails
  ctx.globalCompositeOperation='lighter'; for(const t of state.trails){ ctx.globalAlpha=t.a; ctx.beginPath(); ctx.arc(t.x,t.y,t.r,0,Math.PI*2); ctx.fillStyle=player.color; ctx.fill(); } ctx.globalAlpha=1; ctx.globalCompositeOperation='source-over';

  // ripples/particles
  for(const r of state.ripples){ ctx.beginPath(); ctx.arc(r.x,r.y,r.r,0,Math.PI*2); ctx.strokeStyle=`rgba(255,255,255,${Math.max(0,r.a)})`; ctx.lineWidth=2*DPR; ctx.stroke(); }
  ctx.globalCompositeOperation='lighter'; for(const p of state.particles){ ctx.globalAlpha=p.a; ctx.beginPath(); ctx.arc(p.x,p.y,p.r,0,Math.PI*2); ctx.fillStyle=p.col||'#6bbcff'; ctx.fill(); } ctx.globalAlpha=1; ctx.globalCompositeOperation='source-over';

  // enemies
  for(const e of state.enemies){ drawEnemy(e); }

  // enemy shots
  ctx.globalCompositeOperation='lighter'; for(const s of state.enemyShots){ ctx.beginPath(); ctx.arc(s.x,s.y,s.r,0,Math.PI*2); ctx.fillStyle='#ff9b9b'; ctx.fill(); } ctx.globalCompositeOperation='source-over';

  // powerups
  for(const p of state.powerups){ const pulse=(Math.sin(p.t*0.01)+1)*0.5; ctx.save(); switch(p.type){
    case 'geom': ctx.globalCompositeOperation='lighter'; ctx.translate(p.x,p.y); ctx.rotate(p.t*0.004); const rg=p.r*(0.9+0.2*pulse); ctx.beginPath(); for(let i=0;i<6;i++){ const a=-Math.PI/2 + i*Math.PI/3; const xx=Math.cos(a)*rg, yy=Math.sin(a)*rg; i?ctx.lineTo(xx,yy):ctx.moveTo(xx,yy);} ctx.closePath(); ctx.strokeStyle='#ffd866'; ctx.lineWidth=3*DPR; ctx.stroke(); ctx.globalCompositeOperation='source-over'; break;
    case 'bomb': ctx.translate(p.x,p.y); ctx.rotate(p.t*0.005); ctx.beginPath(); ctx.moveTo(0,-p.r); ctx.lineTo(p.r,0); ctx.lineTo(0,p.r); ctx.lineTo(-p.r,0); ctx.closePath(); ctx.fillStyle='#ffae6b'; ctx.fill(); break;
    case 'shield': ctx.beginPath(); ctx.arc(p.x,p.y,p.r*(0.9+0.2*pulse),0,Math.PI*2); ctx.strokeStyle='#6bffea'; ctx.lineWidth=3*DPR; ctx.stroke(); break;
    case 'spread': ctx.globalCompositeOperation='lighter'; drawStar(p.x,p.y,5,p.r*1.1,p.r*0.5,p.t*0.004); ctx.fillStyle='#ffd2ff'; ctx.shadowColor='#ff8cff'; ctx.shadowBlur=12*DPR; ctx.fill(); ctx.shadowBlur=0; ctx.globalCompositeOperation='source-over'; break;
    case 'haste': ctx.globalCompositeOperation='lighter'; ctx.save(); ctx.translate(p.x,p.y); ctx.rotate(p.t*0.006); ctx.beginPath(); ctx.moveTo(-0.2*p.r, -0.5*p.r); ctx.lineTo(0.18*p.r, -0.1*p.r); ctx.lineTo(-0.05*p.r, -0.1*p.r); ctx.lineTo(0.25*p.r, 0.5*p.r); ctx.lineTo(-0.25*p.r, 0.1*p.r); ctx.lineTo(0, 0.1*p.r); ctx.closePath(); ctx.fillStyle='#7cc3ff'; ctx.shadowColor='#7cc3ff'; ctx.shadowBlur=12*DPR; ctx.fill(); ctx.restore(); ctx.globalCompositeOperation='source-over'; break;
    case 'hp': ctx.beginPath(); ctx.moveTo(p.x, p.y - p.r*0.6); ctx.bezierCurveTo(p.x + p.r*0.8, p.y - p.r*1.2, p.x + p.r*1.2, p.y + p.r*0.2, p.x, p.y + p.r*0.7); ctx.bezierCurveTo(p.x - p.r*1.2, p.y + p.r*0.2, p.x - p.r*0.8, p.y - p.r*1.2, p.x, p.y - p.r*0.6); ctx.fillStyle='#ff6b6b'; ctx.fill(); break;
    case 'magnet': ctx.beginPath(); ctx.arc(p.x, p.y, p.r*0.9, Math.PI*0.2, Math.PI*1.8); ctx.strokeStyle='#b0ff9b'; ctx.lineWidth=4*DPR; ctx.stroke(); break;
    case 'multiBomb': ctx.translate(p.x,p.y); ctx.rotate(0.2*Math.sin(p.t*0.01)); ctx.beginPath(); ctx.rect(-p.r*0.9,-p.r*0.6,p.r*1.8,p.r*1.2); ctx.fillStyle='#ffae6b'; ctx.fill(); ctx.beginPath(); ctx.arc(p.x, p.y - p.r*0.7, p.r*0.5, 0, Math.PI*2); ctx.restore(); break;
    case 'boostAll': ctx.translate(p.x,p.y); ctx.rotate(p.t*0.003); ctx.beginPath(); ctx.arc(0,0,p.r*1.1,0,Math.PI*2); ctx.strokeStyle='#ffd866'; ctx.lineWidth=3*DPR; ctx.stroke(); ctx.beginPath(); ctx.moveTo(-p.r*0.6,0); ctx.lineTo(p.r*0.6,0); ctx.moveTo(0,-p.r*0.6); ctx.lineTo(0,p.r*0.6); ctx.strokeStyle='#ffd866'; ctx.lineWidth=2*DPR; ctx.stroke(); break;
    case 'slow': ctx.beginPath(); ctx.arc(p.x,p.y,p.r,0,Math.PI*2); ctx.strokeStyle='#8bd0ff'; ctx.lineWidth=3*DPR; ctx.setLineDash([4*DPR,3*DPR]); ctx.stroke(); ctx.setLineDash([]); break;
  } ctx.restore(); }

  // bullets
  ctx.globalCompositeOperation='lighter'; for(const b of state.bullets){ ctx.beginPath(); ctx.moveTo(b.px,b.py); ctx.lineTo(b.x,b.y); ctx.strokeStyle='#9be0ff'; ctx.lineWidth=2*DPR; ctx.stroke(); ctx.beginPath(); ctx.arc(b.x,b.y,b.r,0,Math.PI*2); ctx.fillStyle='#e6f9ff'; ctx.fill(); } ctx.globalCompositeOperation='source-over';

  // player
  ctx.save(); ctx.shadowColor=player.color; ctx.shadowBlur=14*DPR; ctx.fillStyle=player.color; ctx.beginPath(); ctx.arc(player.x,player.y,player.r,0,Math.PI*2); ctx.fill(); ctx.shadowBlur=0; ctx.strokeStyle='rgba(255,255,255,0.15)'; ctx.lineWidth=2*DPR; ctx.stroke();
  if(state.invuln>0){ ctx.beginPath(); ctx.arc(player.x,player.y,player.r+5*DPR,0,Math.PI*2); ctx.strokeStyle='rgba(107,255,234,0.8)'; ctx.lineWidth=2*DPR; ctx.stroke(); }
  if(state.shield){ ctx.beginPath(); ctx.arc(player.x,player.y,player.r+9*DPR,0,Math.PI*2); ctx.strokeStyle='rgba(107,255,234,0.9)'; ctx.lineWidth=2*DPR; ctx.stroke(); }
  ctx.restore();

  // floaters
  for(const f of state.floaters){ const fs=(12*UIS*DPR + (1-f.a)*8*DPR); ctx.font=`${fs}px system-ui`; ctx.globalAlpha=f.a; ctx.textAlign='center'; ctx.fillStyle=f.col||'#fff'; ctx.fillText(f.text,f.x,f.y); }
  ctx.globalAlpha=1;

  drawJoystick();

  // ===== UI =====
  drawTopHUD();
  if(state.mode==='start') drawStartOverlay();
  if(state.mode==='gameover') drawEndOverlay();
  if(state.showOptions) drawOptionsOverlay();

  ctx.restore();
}

function drawTopHUD(){
  // Score (big, pulsing)
  const scoreColor = state.mult>=3 ? '#ffd866' : (state.mult===2 ? '#b0ff9b' : '#e6f0ff');
  const baseFont = 26*UIS*DPR;
  const multBoost = Math.max(0, state.mult-1);
  const pulseScale = 1 + 0.12*state.scorePulse;
  const multScale = 1 + 0.22*multBoost;
  const shakeAmp = (0.25 + 0.12*state.scorePulse) * multBoost * DPR;
  const t = state.time*0.02;
  const dx = Math.sin(t*7) * shakeAmp;
  const dy = Math.cos(t*9) * shakeAmp*0.4;
  ctx.save();
  const yTop = Math.max(14*UIS*DPR, 10*DPR) + dy;
  ctx.translate(W/2 + dx, yTop);
  ctx.scale(pulseScale*multScale, pulseScale*multScale);
  ctx.font = `${baseFont}px system-ui`; ctx.textAlign = 'center'; ctx.textBaseline = 'top'; ctx.fillStyle = scoreColor; ctx.shadowColor = scoreColor; ctx.shadowBlur = (12 + 12*multBoost) * DPR;
  ctx.fillText(Math.round(state.displayScore).toLocaleString(), 0, 0);
  ctx.restore();

  // lives (♥ icons), bombs (bomb icon), currency (¤), wave, mult
  ctx.save(); ctx.textAlign='right';
  const lifeX=W-16*DPR, lifeY=18*UIS*DPR;
  for(let i=0;i<state.lives;i++){ ctx.beginPath(); ctx.arc(lifeX-i*18*DPR, lifeY, 6*DPR, 0, Math.PI*2); ctx.fillStyle='#ff6b6b'; ctx.fill(); }
  ctx.restore();

  // right column line 2: bombs + currency
  ctx.fillStyle='rgba(230,240,255,0.9)'; ctx.font=`${12*UIS*DPR}px system-ui`; ctx.textAlign='right';
  ctx.fillText(`💣 ${state.bombs}    ¤ ${state.currency}`, W-10*DPR, lifeY + 12*UIS*DPR);

  // left footer: wave, multiplier, spread, haste
  ctx.fillStyle='rgba(230,240,255,0.85)'; ctx.font=`${12*UIS*DPR}px system-ui`; ctx.textAlign='left';
  const hasteTxt = state.hasteLevel>0? `Haste:${state.hasteLevel}` : '-';
  const spreadTxt = `Spread:${state.spreadLevel}`;
  const shieldTxt = state.shield? 'Shield:ON' : (state.invuln>0?`Shield:${Math.ceil(state.invuln/1000)}s`:'Shield:-');
  ctx.fillText(`Wave ${state.wave}  x${state.mult}  • ${spreadTxt}  • ${hasteTxt}  • ${shieldTxt}`, 10*DPR, H-12*UIS*DPR);

  // banner
  if(state.banner.t>0){ state.banner.t-=16; const a=Math.max(0,Math.min(1,state.banner.t/1400)); ctx.globalAlpha=a; ctx.font=`${28*UIS*DPR}px system-ui`; ctx.textAlign='center'; ctx.fillText(state.banner.text, W/2, H/2); ctx.globalAlpha=1; }

  // combo meter (top-left)
  if(state.combo>0){
    ctx.save(); ctx.textAlign='left'; ctx.font=`${14*UIS*DPR}px system-ui`;
    ctx.fillStyle='#ffd866'; ctx.fillText(`Combo x${state.combo}`, 10*DPR, 18*DPR);
    ctx.restore();
  }
  // new best indicator (top)
  if(state.toldNewBest){
    ctx.save(); ctx.textAlign='center'; ctx.font=`${12*UIS*DPR}px system-ui`; ctx.fillStyle='#b0ff9b';
    ctx.fillText('New Personal Best!', W/2, yTop + 32*DPR);
    ctx.restore();
  }
}

function drawBottomButtons(set){
  for(const key in set){
    const b = set[key];
    const x = b.x, y=b.y, w=b.w, h=b.h;
    ctx.save(); ctx.globalAlpha = state.showBottomUI? 1 : 0; ctx.beginPath(); ctx.roundRect ? ctx.roundRect(x,y,w,h, 6*DPR) : ctx.rect(x,y,w,h);
    ctx.fillStyle='rgba(20,30,55,0.8)'; ctx.fill(); ctx.strokeStyle='rgba(124,195,255,0.5)'; ctx.lineWidth=1*DPR; ctx.stroke();
    ctx.fillStyle='#e6f0ff'; ctx.font=`${16*UIS*DPR}px system-ui`; ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText(b.label, x+w/2, y+h/2);
    ctx.restore();
  }
}

function drawStartOverlay(){
  // Center prompt
  ctx.save();
  ctx.font=`${20*UIS*DPR}px system-ui`; ctx.textAlign='center'; ctx.fillStyle='rgba(230,240,255,0.95)';
  ctx.fillText('Drag to move', W/2, H/2 - 12*DPR);
  ctx.font=`${12*UIS*DPR}px system-ui`; ctx.fillStyle='rgba(230,240,255,0.85)';
  ctx.fillText('Two-finger or double-tap = Bomb', W/2, H/2 + 10*DPR);
  ctx.restore();
  // Bottom bar
  drawBottomButtons(startButtons);
}

function drawEndOverlay(){
  ctx.save();
  ctx.font=`${22*UIS*DPR}px system-ui`; ctx.textAlign='center'; ctx.fillStyle='rgba(230,240,255,0.95)';
  ctx.fillText('Run Over', W/2, H/2 - 32*DPR);
  ctx.font=`${14*UIS*DPR}px system-ui`; ctx.fillText(`Score: ${state.score.toLocaleString()}   •   Best: ${state.best.toLocaleString()}`, W/2, H/2 - 12*DPR);
  if(state.score>=state.best) ctx.fillText('New Personal Best!', W/2, H/2 + 6*DPR);
  // Buttons
  drawBottomButtons(endButtons);
  // Bottom bar (options/store/leader consistent)
  drawBottomButtons(startButtons);
  ctx.restore();
}

function tryRevive(){
  const cost = Math.max(5, Math.round(state.wave*0.6));
  if(state.currency >= cost){
    state.currency -= cost; persist.currency = state.currency; savePersist();
    addFloater(W/2, H/2 - 40*DPR, `Revive -¤${cost}`, '#ffd866');
    // give back one life and spawn protection
    state.lives = Math.max(1, state.lives+1);
    state.mode='play'; state.gameOver=false; state.invuln = 2500;
    state.shield = true; // like normal death flow
    state.enemyShots.length=0; state.enemies.length=0;
  }else{
    dropBanner('Not enough currency');
  }
}

function drawOptionsOverlay(){
  const w = Math.min(W*0.9, 300*DPR), h=170*DPR;
  const x = (W-w)/2, y=(H-h)/2;
  ctx.save();
  ctx.beginPath(); ctx.roundRect ? ctx.roundRect(x,y,w,h,10*DPR) : ctx.rect(x,y,w,h);
  ctx.fillStyle='rgba(10,15,30,0.95)'; ctx.fill();
  ctx.strokeStyle='rgba(124,195,255,0.6)'; ctx.lineWidth=2*DPR; ctx.stroke();
  ctx.fillStyle='#e6f0ff'; ctx.font=`${16*UIS*DPR}px system-ui`; ctx.textAlign='left';
  ctx.fillText('Options', x+12*DPR, y+20*DPR);
  ctx.font=`${12*UIS*DPR}px system-ui`;
  ctx.fillText(`Control: ${state.control}  (tap to toggle)`, x+12*DPR, y+50*DPR);
  ctx.fillText(`Aim: ${state.aim}  (tap to toggle)`, x+12*DPR, y+70*DPR);
  ctx.fillText(`Muted: ${state.muted? 'yes':'no'}  (tap to toggle)`, x+12*DPR, y+90*DPR);
  ctx.fillText('Tap anywhere to close', x+12*DPR, y+h-16*DPR);

  // basic interaction area: toggle based on last pointer
  // We don't capture clicks separately; keep simple: a tap while open cycles all
  ctx.restore();
}
canvas.addEventListener('click', ()=>{
  if(state.showOptions){
    // cycle simple toggles in order of taps
    if(state._optClickCycle===0 || state._optClickCycle===undefined){
      state.control = (state.control==='drag')?'tap':(state.control==='tap')?'both':'drag';
      state._optClickCycle=1;
    } else if(state._optClickCycle===1){
      state.aim = (state.aim==='nearest')?'directional':'nearest';
      state._optClickCycle=2;
    } else {
      state.muted = !state.muted;
      state._optClickCycle=0;
      state.showOptions=false;
    }
    persist.opts = {control:state.control, aim:state.aim, muted:state.muted}; savePersist();
  }
});

// ===== Boot =====
function boot(fromRestart){
  resize();
  Object.assign(state, {
    mode: fromRestart? 'play':'start',
    time:0, shake:0, hitstop:0, score:0, displayScore:0, scorePulse:0,
    lives:3, wave:1, gameOver:false,
    lastSpawn:0, spawnDelay:650, waveTarget:12, spawned:0,
    lastShot:0, shootDelay:380, bombs:1,
    invuln:0, shield:false,
    spreadLevel:0, hasteLevel:0,
    slowTimer:0, boostAllTimer:0, multBoostTimer:0,
    mult:1, multTimer:0, geomCapReached:false,
    banner:{text:'',t:0}, joy:{active:false,ox:0,oy:0,x:0,y:0,a:0,t:0},
    cometTimer: rand(8000,16000), bgPulse:0,
    showOptions:false, showBottomUI:!fromRestart,
    recentKills:[], combo:0, comboTimer:0, nearMissTimer:0,
    currency: persist.currency, best: persist.best, toldNewBest:false,
    milestones:{5000:false,10000:false,20000:false,50000:false},
    control: persist.opts.control, aim: persist.opts.aim, muted: persist.opts.muted,
    livesWaveLoss:0, lastWaveLife:3
  });
  state.enemies.length=0; state.bullets.length=0; state.enemyShots.length=0; state.trails.length=0; state.floaters.length=0; state.ripples.length=0; state.particles.length=0; state.powerups.length=0; state.comets.length=0;
  player.r=16*DPR; player.speed=0.38*DPR; player.x=W/2; player.y=H/2; player.tx=player.x; player.ty=player.y; player.mvx=0; player.mvy=0;
  if(state.mode==='play'){ dropBanner('Wave 1'); spawnEnemy(); spawnEnemy(); }
  let last=performance.now();
  function loop(now){ try{
      requestAnimationFrame(loop);
      const dt=Math.min(50, now-last); last=now;
      update(dt,now);
      updateBoostAllDecay();
      // milestones
      checkMilestones();
      draw();
      state.scorePulse *= 0.9;
      state.shake*=0.92;
      // decay old kills for combo
      const tcut = now - 1500; state.recentKills = state.recentKills.filter(t=>t>=tcut);
    }catch(err){ showError(err); } }
  requestAnimationFrame(loop);
}

function checkMilestones(){
  const marks = [5000,10000,20000,50000];
  for(const m of marks){
    if(!state.milestones[m] && state.score>=m){
      state.milestones[m]=true;
      addFloater(W/2, H*0.3, `Reward Unlocked: ¤${Math.round(m/5000)}`, '#ffd866');
      awardCurrency(Math.round(m/5000), {x:W/2, y:H*0.3});
    }
  }
  if(state.score>state.best && !state.toldNewBest){
    state.toldNewBest = true;
    addFloater(W/2, H*0.35, 'New Personal Best!', '#b0ff9b');
  }
}

boot();
</script>

<script>
// (Optional) Service worker — keep version bump updated when you publish
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('./sw.js?v=ztap-arena-v5')
    .then(() => console.log("✅ Service Worker registered"))
    .catch(err => console.warn("SW registration failed:", err));
}
</script>

</body>
</html>
